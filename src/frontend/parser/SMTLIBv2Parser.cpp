
// Generated from SMTLIBv2.g4 by ANTLR 4.13.1


#include "SMTLIBv2Listener.h"
#include "SMTLIBv2Visitor.h"

#include "SMTLIBv2Parser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct SMTLIBv2ParserStaticData final {
  SMTLIBv2ParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  SMTLIBv2ParserStaticData(const SMTLIBv2ParserStaticData&) = delete;
  SMTLIBv2ParserStaticData(SMTLIBv2ParserStaticData&&) = delete;
  SMTLIBv2ParserStaticData& operator=(const SMTLIBv2ParserStaticData&) = delete;
  SMTLIBv2ParserStaticData& operator=(SMTLIBv2ParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag smtlibv2ParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
SMTLIBv2ParserStaticData *smtlibv2ParserStaticData = nullptr;

void smtlibv2ParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (smtlibv2ParserStaticData != nullptr) {
    return;
  }
#else
  assert(smtlibv2ParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<SMTLIBv2ParserStaticData>(
    std::vector<std::string>{
      "start", "response", "generalReservedWord", "simpleSymbol", "quotedSymbol", 
      "predefSymbol", "predefKeyword", "symbol", "numeral", "decimal", "hexadecimal", 
      "binary", "string", "keyword", "spec_constant", "s_expr", "index", 
      "identifier", "attribute_value", "attribute", "sort", "qual_identifier", 
      "var_binding", "sorted_var", "pattern", "match_case", "term", "sort_symbol_decl", 
      "meta_spec_constant", "fun_symbol_decl", "par_fun_symbol_decl", "theory_attribute", 
      "theory_decl", "logic_attribue", "logic", "sort_dec", "selector_dec", 
      "constructor_dec", "datatype_dec", "function_dec", "function_def", 
      "prop_literal", "script", "cmd_assert", "cmd_checkSat", "cmd_checkSatAssuming", 
      "cmd_declareConst", "cmd_declareDatatype", "cmd_declareDatatypes", 
      "cmd_declareFun", "cmd_declareSort", "cmd_defineFun", "cmd_defineFunRec", 
      "cmd_defineFunsRec", "cmd_defineSort", "cmd_echo", "cmd_exit", "cmd_getAssertions", 
      "cmd_getAssignment", "cmd_getInfo", "cmd_getModel", "cmd_getOption", 
      "cmd_getProof", "cmd_getUnsatAssumptions", "cmd_getUnsatCore", "cmd_getValue", 
      "cmd_pop", "cmd_push", "cmd_reset", "cmd_resetAssertions", "cmd_setInfo", 
      "cmd_setLogic", "cmd_setOption", "command", "b_value", "option", "info_flag", 
      "error_behaviour", "reason_unknown", "model_response", "info_response", 
      "valuation_pair", "t_valuation_pair", "check_sat_response", "echo_response", 
      "get_assertions_response", "get_assignment_response", "get_info_response", 
      "get_model_response", "get_option_response", "get_proof_response", 
      "get_unsat_assump_response", "get_unsat_core_response", "get_value_response", 
      "specific_success_response", "general_response"
    },
    std::vector<std::string>{
      "", "", "'('", "')'", "';'", "", "", "'not'", "'Bool'", "'continued-execution'", 
      "'error'", "'false'", "'immediate-exit'", "'incomplete'", "'logic'", 
      "'memout'", "'sat'", "'success'", "'theory'", "'true'", "'unknown'", 
      "'unsupported'", "'unsat'", "'assert'", "'check-sat'", "'check-sat-assuming'", 
      "'declare-const'", "'declare-datatype'", "'declare-datatypes'", "'declare-fun'", 
      "'declare-sort'", "'define-fun'", "'define-fun-rec'", "'define-funs-rec'", 
      "'define-sort'", "'echo'", "'exit'", "'get-assertions'", "'get-assignment'", 
      "'get-info'", "'get-model'", "'get-option'", "'get-proof'", "'get-unsat-assumptions'", 
      "'get-unsat-core'", "'get-value'", "'pop'", "'push'", "'reset'", "'reset-assertions'", 
      "'set-info'", "'set-logic'", "'set-option'", "'!'", "'_'", "'as'", 
      "'BINARY'", "'DECIMAL'", "'exists'", "'HEXADECIMAL'", "'forall'", 
      "'let'", "'match'", "'NUMERAL'", "'par'", "'string'", "", "", "", 
      "", "':'", "':all-statistics'", "':assertion-stack-levels'", "':authors'", 
      "':category'", "':chainable'", "':definition'", "':diagnostic-output-channel'", 
      "':error-behavior'", "':extensions'", "':funs'", "':funs-description'", 
      "':global-declarations'", "':interactive-mode'", "':language'", "':left-assoc'", 
      "':license'", "':named'", "':name'", "':notes'", "':pattern'", "':print-success'", 
      "':produce-assertions'", "':produce-assignments'", "':produce-models'", 
      "':produce-proofs'", "':produce-unsat-assumptions'", "':produce-unsat-cores'", 
      "':random-seed'", "':reason-unknown'", "':regular-output-channel'", 
      "':reproducible-resource-limit'", "':right-assoc'", "':smt-lib-version'", 
      "':sorts'", "':sorts-description'", "':source'", "':status'", "':theories'", 
      "':values'", "':verbosity'", "':version'"
    },
    std::vector<std::string>{
      "", "Comment", "ParOpen", "ParClose", "Semicolon", "String", "QuotedSymbol", 
      "PS_Not", "PS_Bool", "PS_ContinuedExecution", "PS_Error", "PS_False", 
      "PS_ImmediateExit", "PS_Incomplete", "PS_Logic", "PS_Memout", "PS_Sat", 
      "PS_Success", "PS_Theory", "PS_True", "PS_Unknown", "PS_Unsupported", 
      "PS_Unsat", "CMD_Assert", "CMD_CheckSat", "CMD_CheckSatAssuming", 
      "CMD_DeclareConst", "CMD_DeclareDatatype", "CMD_DeclareDatatypes", 
      "CMD_DeclareFun", "CMD_DeclareSort", "CMD_DefineFun", "CMD_DefineFunRec", 
      "CMD_DefineFunsRec", "CMD_DefineSort", "CMD_Echo", "CMD_Exit", "CMD_GetAssertions", 
      "CMD_GetAssignment", "CMD_GetInfo", "CMD_GetModel", "CMD_GetOption", 
      "CMD_GetProof", "CMD_GetUnsatAssumptions", "CMD_GetUnsatCore", "CMD_GetValue", 
      "CMD_Pop", "CMD_Push", "CMD_Reset", "CMD_ResetAssertions", "CMD_SetInfo", 
      "CMD_SetLogic", "CMD_SetOption", "GRW_Exclamation", "GRW_Underscore", 
      "GRW_As", "GRW_Binary", "GRW_Decimal", "GRW_Exists", "GRW_Hexadecimal", 
      "GRW_Forall", "GRW_Let", "GRW_Match", "GRW_Numeral", "GRW_Par", "GRW_String", 
      "Numeral", "Binary", "HexDecimal", "Decimal", "Colon", "PK_AllStatistics", 
      "PK_AssertionStackLevels", "PK_Authors", "PK_Category", "PK_Chainable", 
      "PK_Definition", "PK_DiagnosticOutputChannel", "PK_ErrorBehaviour", 
      "PK_Extension", "PK_Funs", "PK_FunsDescription", "PK_GlobalDeclarations", 
      "PK_InteractiveMode", "PK_Language", "PK_LeftAssoc", "PK_License", 
      "PK_Named", "PK_Name", "PK_Notes", "PK_Pattern", "PK_PrintSuccess", 
      "PK_ProduceAssertions", "PK_ProduceAssignments", "PK_ProduceModels", 
      "PK_ProduceProofs", "PK_ProduceUnsatAssumptions", "PK_ProduceUnsatCores", 
      "PK_RandomSeed", "PK_ReasonUnknown", "PK_RegularOutputChannel", "PK_ReproducibleResourceLimit", 
      "PK_RightAssoc", "PK_SmtLibVersion", "PK_Sorts", "PK_SortsDescription", 
      "PK_Source", "PK_Status", "PK_Theories", "PK_Values", "PK_Verbosity", 
      "PK_Version", "UndefinedSymbol", "WS"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,113,1093,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,1,0,1,0,1,0,1,1,1,1,1,1,
  	1,2,1,2,1,3,1,3,3,3,203,8,3,1,4,1,4,1,5,1,5,1,6,1,6,1,7,1,7,3,7,213,8,
  	7,1,8,1,8,1,9,1,9,1,10,1,10,1,11,1,11,1,12,1,12,1,13,1,13,1,13,3,13,228,
  	8,13,1,14,1,14,1,14,1,14,1,14,3,14,235,8,14,1,15,1,15,1,15,1,15,1,15,
  	5,15,242,8,15,10,15,12,15,245,9,15,1,15,3,15,248,8,15,1,16,1,16,3,16,
  	252,8,16,1,17,1,17,1,17,1,17,1,17,4,17,259,8,17,11,17,12,17,260,1,17,
  	1,17,3,17,265,8,17,1,18,1,18,1,18,1,18,5,18,271,8,18,10,18,12,18,274,
  	9,18,1,18,3,18,277,8,18,1,19,1,19,1,19,1,19,3,19,283,8,19,1,20,1,20,1,
  	20,1,20,4,20,289,8,20,11,20,12,20,290,1,20,1,20,3,20,295,8,20,1,21,1,
  	21,1,21,1,21,1,21,1,21,1,21,3,21,304,8,21,1,22,1,22,1,22,1,22,1,22,1,
  	23,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,4,24,320,8,24,11,24,12,24,
  	321,1,24,1,24,3,24,326,8,24,1,25,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,
  	26,1,26,4,26,338,8,26,11,26,12,26,339,1,26,1,26,1,26,1,26,1,26,1,26,4,
  	26,348,8,26,11,26,12,26,349,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,4,
  	26,360,8,26,11,26,12,26,361,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,4,
  	26,372,8,26,11,26,12,26,373,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,
  	26,4,26,385,8,26,11,26,12,26,386,1,26,1,26,1,26,1,26,1,26,1,26,1,26,4,
  	26,396,8,26,11,26,12,26,397,1,26,1,26,3,26,402,8,26,1,27,1,27,1,27,1,
  	27,5,27,408,8,27,10,27,12,27,411,9,27,1,27,1,27,1,28,1,28,1,29,1,29,1,
  	29,1,29,5,29,421,8,29,10,29,12,29,424,9,29,1,29,1,29,1,29,1,29,1,29,1,
  	29,5,29,432,8,29,10,29,12,29,435,9,29,1,29,1,29,1,29,1,29,1,29,4,29,442,
  	8,29,11,29,12,29,443,1,29,5,29,447,8,29,10,29,12,29,450,9,29,1,29,1,29,
  	3,29,454,8,29,1,30,1,30,1,30,1,30,1,30,4,30,461,8,30,11,30,12,30,462,
  	1,30,1,30,1,30,1,30,4,30,469,8,30,11,30,12,30,470,1,30,5,30,474,8,30,
  	10,30,12,30,477,9,30,1,30,1,30,1,30,3,30,482,8,30,1,31,1,31,1,31,4,31,
  	487,8,31,11,31,12,31,488,1,31,1,31,1,31,1,31,1,31,4,31,496,8,31,11,31,
  	12,31,497,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,
  	1,31,3,31,513,8,31,1,32,1,32,1,32,1,32,4,32,519,8,32,11,32,12,32,520,
  	1,32,1,32,1,33,1,33,1,33,4,33,528,8,33,11,33,12,33,529,1,33,1,33,1,33,
  	1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,543,8,33,1,34,1,34,1,34,
  	1,34,4,34,549,8,34,11,34,12,34,550,1,34,1,34,1,35,1,35,1,35,1,35,1,35,
  	1,36,1,36,1,36,1,36,1,36,1,37,1,37,1,37,5,37,568,8,37,10,37,12,37,571,
  	9,37,1,37,1,37,1,38,1,38,4,38,577,8,38,11,38,12,38,578,1,38,1,38,1,38,
  	1,38,1,38,1,38,4,38,587,8,38,11,38,12,38,588,1,38,1,38,1,38,4,38,594,
  	8,38,11,38,12,38,595,1,38,1,38,1,38,3,38,601,8,38,1,39,1,39,1,39,1,39,
  	5,39,607,8,39,10,39,12,39,610,9,39,1,39,1,39,1,39,1,39,1,40,1,40,1,40,
  	5,40,619,8,40,10,40,12,40,622,9,40,1,40,1,40,1,40,1,40,1,41,1,41,1,41,
  	1,41,1,41,1,41,3,41,634,8,41,1,42,5,42,637,8,42,10,42,12,42,640,9,42,
  	1,43,1,43,1,44,1,44,1,45,1,45,1,46,1,46,1,47,1,47,1,48,1,48,1,49,1,49,
  	1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,54,1,54,1,55,1,55,1,56,1,56,
  	1,57,1,57,1,58,1,58,1,59,1,59,1,60,1,60,1,61,1,61,1,62,1,62,1,63,1,63,
  	1,64,1,64,1,65,1,65,1,66,1,66,1,67,1,67,1,68,1,68,1,69,1,69,1,70,1,70,
  	1,71,1,71,1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,4,73,731,8,73,11,73,12,73,732,1,73,1,73,1,73,
  	4,73,738,8,73,11,73,12,73,739,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	5,73,750,8,73,10,73,12,73,753,9,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,4,73,779,8,73,11,73,12,73,780,1,73,1,73,1,73,4,73,786,
  	8,73,11,73,12,73,787,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,5,73,798,
  	8,73,10,73,12,73,801,9,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	4,73,854,8,73,11,73,12,73,855,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	3,73,894,8,73,1,74,1,74,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,1,75,1,75,1,75,1,75,3,75,927,8,75,1,76,1,76,1,76,1,76,1,76,
  	1,76,1,76,1,76,3,76,937,8,76,1,77,1,77,1,78,1,78,1,78,3,78,944,8,78,1,
  	79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,4,
  	79,960,8,79,11,79,12,79,961,1,79,1,79,1,79,4,79,967,8,79,11,79,12,79,
  	968,1,79,1,79,1,79,3,79,974,8,79,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,
  	80,1,80,1,80,1,80,1,80,1,80,3,80,989,8,80,1,81,1,81,1,81,1,81,1,81,1,
  	82,1,82,1,82,1,82,1,82,1,83,1,83,1,84,1,84,1,85,1,85,5,85,1007,8,85,10,
  	85,12,85,1010,9,85,1,85,1,85,1,86,1,86,5,86,1016,8,86,10,86,12,86,1019,
  	9,86,1,86,1,86,1,87,1,87,4,87,1025,8,87,11,87,12,87,1026,1,87,1,87,1,
  	88,1,88,5,88,1033,8,88,10,88,12,88,1036,9,88,1,88,1,88,1,89,1,89,1,90,
  	1,90,1,91,1,91,5,91,1046,8,91,10,91,12,91,1049,9,91,1,91,1,91,1,92,1,
  	92,5,92,1055,8,92,10,92,12,92,1058,9,92,1,92,1,92,1,93,1,93,4,93,1064,
  	8,93,11,93,12,93,1065,1,93,1,93,1,94,1,94,1,94,1,94,1,94,1,94,1,94,1,
  	94,1,94,1,94,1,94,3,94,1081,8,94,1,95,1,95,1,95,1,95,1,95,1,95,1,95,1,
  	95,3,95,1091,8,95,1,95,0,0,96,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
  	30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,
  	76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
  	118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
  	154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,
  	190,0,7,1,0,53,65,1,0,7,22,1,0,71,111,3,0,57,57,63,63,65,65,2,0,11,11,
  	19,19,2,0,9,9,12,12,3,0,16,16,20,20,22,22,1158,0,192,1,0,0,0,2,195,1,
  	0,0,0,4,198,1,0,0,0,6,202,1,0,0,0,8,204,1,0,0,0,10,206,1,0,0,0,12,208,
  	1,0,0,0,14,212,1,0,0,0,16,214,1,0,0,0,18,216,1,0,0,0,20,218,1,0,0,0,22,
  	220,1,0,0,0,24,222,1,0,0,0,26,227,1,0,0,0,28,234,1,0,0,0,30,247,1,0,0,
  	0,32,251,1,0,0,0,34,264,1,0,0,0,36,276,1,0,0,0,38,282,1,0,0,0,40,294,
  	1,0,0,0,42,303,1,0,0,0,44,305,1,0,0,0,46,310,1,0,0,0,48,325,1,0,0,0,50,
  	327,1,0,0,0,52,401,1,0,0,0,54,403,1,0,0,0,56,414,1,0,0,0,58,453,1,0,0,
  	0,60,481,1,0,0,0,62,512,1,0,0,0,64,514,1,0,0,0,66,542,1,0,0,0,68,544,
  	1,0,0,0,70,554,1,0,0,0,72,559,1,0,0,0,74,564,1,0,0,0,76,600,1,0,0,0,78,
  	602,1,0,0,0,80,615,1,0,0,0,82,633,1,0,0,0,84,638,1,0,0,0,86,641,1,0,0,
  	0,88,643,1,0,0,0,90,645,1,0,0,0,92,647,1,0,0,0,94,649,1,0,0,0,96,651,
  	1,0,0,0,98,653,1,0,0,0,100,655,1,0,0,0,102,657,1,0,0,0,104,659,1,0,0,
  	0,106,661,1,0,0,0,108,663,1,0,0,0,110,665,1,0,0,0,112,667,1,0,0,0,114,
  	669,1,0,0,0,116,671,1,0,0,0,118,673,1,0,0,0,120,675,1,0,0,0,122,677,1,
  	0,0,0,124,679,1,0,0,0,126,681,1,0,0,0,128,683,1,0,0,0,130,685,1,0,0,0,
  	132,687,1,0,0,0,134,689,1,0,0,0,136,691,1,0,0,0,138,693,1,0,0,0,140,695,
  	1,0,0,0,142,697,1,0,0,0,144,699,1,0,0,0,146,893,1,0,0,0,148,895,1,0,0,
  	0,150,926,1,0,0,0,152,936,1,0,0,0,154,938,1,0,0,0,156,943,1,0,0,0,158,
  	973,1,0,0,0,160,988,1,0,0,0,162,990,1,0,0,0,164,995,1,0,0,0,166,1000,
  	1,0,0,0,168,1002,1,0,0,0,170,1004,1,0,0,0,172,1013,1,0,0,0,174,1022,1,
  	0,0,0,176,1030,1,0,0,0,178,1039,1,0,0,0,180,1041,1,0,0,0,182,1043,1,0,
  	0,0,184,1052,1,0,0,0,186,1061,1,0,0,0,188,1080,1,0,0,0,190,1090,1,0,0,
  	0,192,193,3,84,42,0,193,194,5,0,0,1,194,1,1,0,0,0,195,196,3,190,95,0,
  	196,197,5,0,0,1,197,3,1,0,0,0,198,199,7,0,0,0,199,5,1,0,0,0,200,203,3,
  	10,5,0,201,203,5,112,0,0,202,200,1,0,0,0,202,201,1,0,0,0,203,7,1,0,0,
  	0,204,205,5,6,0,0,205,9,1,0,0,0,206,207,7,1,0,0,207,11,1,0,0,0,208,209,
  	7,2,0,0,209,13,1,0,0,0,210,213,3,6,3,0,211,213,3,8,4,0,212,210,1,0,0,
  	0,212,211,1,0,0,0,213,15,1,0,0,0,214,215,5,66,0,0,215,17,1,0,0,0,216,
  	217,5,69,0,0,217,19,1,0,0,0,218,219,5,68,0,0,219,21,1,0,0,0,220,221,5,
  	67,0,0,221,23,1,0,0,0,222,223,5,5,0,0,223,25,1,0,0,0,224,228,3,12,6,0,
  	225,226,5,70,0,0,226,228,3,6,3,0,227,224,1,0,0,0,227,225,1,0,0,0,228,
  	27,1,0,0,0,229,235,3,16,8,0,230,235,3,18,9,0,231,235,3,20,10,0,232,235,
  	3,22,11,0,233,235,3,24,12,0,234,229,1,0,0,0,234,230,1,0,0,0,234,231,1,
  	0,0,0,234,232,1,0,0,0,234,233,1,0,0,0,235,29,1,0,0,0,236,248,3,28,14,
  	0,237,248,3,14,7,0,238,248,3,26,13,0,239,243,5,2,0,0,240,242,3,30,15,
  	0,241,240,1,0,0,0,242,245,1,0,0,0,243,241,1,0,0,0,243,244,1,0,0,0,244,
  	246,1,0,0,0,245,243,1,0,0,0,246,248,5,3,0,0,247,236,1,0,0,0,247,237,1,
  	0,0,0,247,238,1,0,0,0,247,239,1,0,0,0,248,31,1,0,0,0,249,252,3,16,8,0,
  	250,252,3,14,7,0,251,249,1,0,0,0,251,250,1,0,0,0,252,33,1,0,0,0,253,265,
  	3,14,7,0,254,255,5,2,0,0,255,256,5,54,0,0,256,258,3,14,7,0,257,259,3,
  	32,16,0,258,257,1,0,0,0,259,260,1,0,0,0,260,258,1,0,0,0,260,261,1,0,0,
  	0,261,262,1,0,0,0,262,263,5,3,0,0,263,265,1,0,0,0,264,253,1,0,0,0,264,
  	254,1,0,0,0,265,35,1,0,0,0,266,277,3,28,14,0,267,277,3,14,7,0,268,272,
  	5,2,0,0,269,271,3,30,15,0,270,269,1,0,0,0,271,274,1,0,0,0,272,270,1,0,
  	0,0,272,273,1,0,0,0,273,275,1,0,0,0,274,272,1,0,0,0,275,277,5,3,0,0,276,
  	266,1,0,0,0,276,267,1,0,0,0,276,268,1,0,0,0,277,37,1,0,0,0,278,283,3,
  	26,13,0,279,280,3,26,13,0,280,281,3,36,18,0,281,283,1,0,0,0,282,278,1,
  	0,0,0,282,279,1,0,0,0,283,39,1,0,0,0,284,295,3,34,17,0,285,286,5,2,0,
  	0,286,288,3,34,17,0,287,289,3,40,20,0,288,287,1,0,0,0,289,290,1,0,0,0,
  	290,288,1,0,0,0,290,291,1,0,0,0,291,292,1,0,0,0,292,293,5,3,0,0,293,295,
  	1,0,0,0,294,284,1,0,0,0,294,285,1,0,0,0,295,41,1,0,0,0,296,304,3,34,17,
  	0,297,298,5,2,0,0,298,299,5,55,0,0,299,300,3,34,17,0,300,301,3,40,20,
  	0,301,302,5,3,0,0,302,304,1,0,0,0,303,296,1,0,0,0,303,297,1,0,0,0,304,
  	43,1,0,0,0,305,306,5,2,0,0,306,307,3,14,7,0,307,308,3,52,26,0,308,309,
  	5,3,0,0,309,45,1,0,0,0,310,311,5,2,0,0,311,312,3,14,7,0,312,313,3,40,
  	20,0,313,314,5,3,0,0,314,47,1,0,0,0,315,326,3,14,7,0,316,317,5,2,0,0,
  	317,319,3,14,7,0,318,320,3,14,7,0,319,318,1,0,0,0,320,321,1,0,0,0,321,
  	319,1,0,0,0,321,322,1,0,0,0,322,323,1,0,0,0,323,324,5,3,0,0,324,326,1,
  	0,0,0,325,315,1,0,0,0,325,316,1,0,0,0,326,49,1,0,0,0,327,328,5,2,0,0,
  	328,329,3,48,24,0,329,330,3,52,26,0,330,331,5,3,0,0,331,51,1,0,0,0,332,
  	402,3,28,14,0,333,402,3,42,21,0,334,335,5,2,0,0,335,337,3,42,21,0,336,
  	338,3,52,26,0,337,336,1,0,0,0,338,339,1,0,0,0,339,337,1,0,0,0,339,340,
  	1,0,0,0,340,341,1,0,0,0,341,342,5,3,0,0,342,402,1,0,0,0,343,344,5,2,0,
  	0,344,345,5,61,0,0,345,347,5,2,0,0,346,348,3,44,22,0,347,346,1,0,0,0,
  	348,349,1,0,0,0,349,347,1,0,0,0,349,350,1,0,0,0,350,351,1,0,0,0,351,352,
  	5,3,0,0,352,353,3,52,26,0,353,354,5,3,0,0,354,402,1,0,0,0,355,356,5,2,
  	0,0,356,357,5,60,0,0,357,359,5,2,0,0,358,360,3,46,23,0,359,358,1,0,0,
  	0,360,361,1,0,0,0,361,359,1,0,0,0,361,362,1,0,0,0,362,363,1,0,0,0,363,
  	364,5,3,0,0,364,365,3,52,26,0,365,366,5,3,0,0,366,402,1,0,0,0,367,368,
  	5,2,0,0,368,369,5,58,0,0,369,371,5,2,0,0,370,372,3,46,23,0,371,370,1,
  	0,0,0,372,373,1,0,0,0,373,371,1,0,0,0,373,374,1,0,0,0,374,375,1,0,0,0,
  	375,376,5,3,0,0,376,377,3,52,26,0,377,378,5,3,0,0,378,402,1,0,0,0,379,
  	380,5,2,0,0,380,381,5,62,0,0,381,382,3,52,26,0,382,384,5,2,0,0,383,385,
  	3,50,25,0,384,383,1,0,0,0,385,386,1,0,0,0,386,384,1,0,0,0,386,387,1,0,
  	0,0,387,388,1,0,0,0,388,389,5,3,0,0,389,390,5,3,0,0,390,402,1,0,0,0,391,
  	392,5,2,0,0,392,393,5,53,0,0,393,395,3,52,26,0,394,396,3,38,19,0,395,
  	394,1,0,0,0,396,397,1,0,0,0,397,395,1,0,0,0,397,398,1,0,0,0,398,399,1,
  	0,0,0,399,400,5,3,0,0,400,402,1,0,0,0,401,332,1,0,0,0,401,333,1,0,0,0,
  	401,334,1,0,0,0,401,343,1,0,0,0,401,355,1,0,0,0,401,367,1,0,0,0,401,379,
  	1,0,0,0,401,391,1,0,0,0,402,53,1,0,0,0,403,404,5,2,0,0,404,405,3,34,17,
  	0,405,409,3,16,8,0,406,408,3,38,19,0,407,406,1,0,0,0,408,411,1,0,0,0,
  	409,407,1,0,0,0,409,410,1,0,0,0,410,412,1,0,0,0,411,409,1,0,0,0,412,413,
  	5,3,0,0,413,55,1,0,0,0,414,415,7,3,0,0,415,57,1,0,0,0,416,417,5,2,0,0,
  	417,418,3,28,14,0,418,422,3,40,20,0,419,421,3,38,19,0,420,419,1,0,0,0,
  	421,424,1,0,0,0,422,420,1,0,0,0,422,423,1,0,0,0,423,425,1,0,0,0,424,422,
  	1,0,0,0,425,426,5,3,0,0,426,454,1,0,0,0,427,428,5,2,0,0,428,429,3,56,
  	28,0,429,433,3,40,20,0,430,432,3,38,19,0,431,430,1,0,0,0,432,435,1,0,
  	0,0,433,431,1,0,0,0,433,434,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
  	437,5,3,0,0,437,454,1,0,0,0,438,439,5,2,0,0,439,441,3,34,17,0,440,442,
  	3,40,20,0,441,440,1,0,0,0,442,443,1,0,0,0,443,441,1,0,0,0,443,444,1,0,
  	0,0,444,448,1,0,0,0,445,447,3,38,19,0,446,445,1,0,0,0,447,450,1,0,0,0,
  	448,446,1,0,0,0,448,449,1,0,0,0,449,451,1,0,0,0,450,448,1,0,0,0,451,452,
  	5,3,0,0,452,454,1,0,0,0,453,416,1,0,0,0,453,427,1,0,0,0,453,438,1,0,0,
  	0,454,59,1,0,0,0,455,482,3,58,29,0,456,457,5,2,0,0,457,458,5,64,0,0,458,
  	460,5,2,0,0,459,461,3,14,7,0,460,459,1,0,0,0,461,462,1,0,0,0,462,460,
  	1,0,0,0,462,463,1,0,0,0,463,464,1,0,0,0,464,465,5,3,0,0,465,466,5,2,0,
  	0,466,468,3,34,17,0,467,469,3,40,20,0,468,467,1,0,0,0,469,470,1,0,0,0,
  	470,468,1,0,0,0,470,471,1,0,0,0,471,475,1,0,0,0,472,474,3,38,19,0,473,
  	472,1,0,0,0,474,477,1,0,0,0,475,473,1,0,0,0,475,476,1,0,0,0,476,478,1,
  	0,0,0,477,475,1,0,0,0,478,479,5,3,0,0,479,480,5,3,0,0,480,482,1,0,0,0,
  	481,455,1,0,0,0,481,456,1,0,0,0,482,61,1,0,0,0,483,484,5,104,0,0,484,
  	486,5,2,0,0,485,487,3,54,27,0,486,485,1,0,0,0,487,488,1,0,0,0,488,486,
  	1,0,0,0,488,489,1,0,0,0,489,490,1,0,0,0,490,491,5,3,0,0,491,513,1,0,0,
  	0,492,493,5,80,0,0,493,495,5,2,0,0,494,496,3,60,30,0,495,494,1,0,0,0,
  	496,497,1,0,0,0,497,495,1,0,0,0,497,498,1,0,0,0,498,499,1,0,0,0,499,500,
  	5,3,0,0,500,513,1,0,0,0,501,502,5,105,0,0,502,513,3,24,12,0,503,504,5,
  	81,0,0,504,513,3,24,12,0,505,506,5,76,0,0,506,513,3,24,12,0,507,508,5,
  	109,0,0,508,513,3,24,12,0,509,510,5,89,0,0,510,513,3,24,12,0,511,513,
  	3,38,19,0,512,483,1,0,0,0,512,492,1,0,0,0,512,501,1,0,0,0,512,503,1,0,
  	0,0,512,505,1,0,0,0,512,507,1,0,0,0,512,509,1,0,0,0,512,511,1,0,0,0,513,
  	63,1,0,0,0,514,515,5,2,0,0,515,516,5,18,0,0,516,518,3,14,7,0,517,519,
  	3,62,31,0,518,517,1,0,0,0,519,520,1,0,0,0,520,518,1,0,0,0,520,521,1,0,
  	0,0,521,522,1,0,0,0,522,523,5,3,0,0,523,65,1,0,0,0,524,525,5,108,0,0,
  	525,527,5,2,0,0,526,528,3,14,7,0,527,526,1,0,0,0,528,529,1,0,0,0,529,
  	527,1,0,0,0,529,530,1,0,0,0,530,531,1,0,0,0,531,532,5,3,0,0,532,543,1,
  	0,0,0,533,534,5,84,0,0,534,543,3,24,12,0,535,536,5,79,0,0,536,543,3,24,
  	12,0,537,538,5,109,0,0,538,543,3,24,12,0,539,540,5,89,0,0,540,543,3,24,
  	12,0,541,543,3,38,19,0,542,524,1,0,0,0,542,533,1,0,0,0,542,535,1,0,0,
  	0,542,537,1,0,0,0,542,539,1,0,0,0,542,541,1,0,0,0,543,67,1,0,0,0,544,
  	545,5,2,0,0,545,546,5,14,0,0,546,548,3,14,7,0,547,549,3,66,33,0,548,547,
  	1,0,0,0,549,550,1,0,0,0,550,548,1,0,0,0,550,551,1,0,0,0,551,552,1,0,0,
  	0,552,553,5,3,0,0,553,69,1,0,0,0,554,555,5,2,0,0,555,556,3,14,7,0,556,
  	557,3,16,8,0,557,558,5,3,0,0,558,71,1,0,0,0,559,560,5,2,0,0,560,561,3,
  	14,7,0,561,562,3,40,20,0,562,563,5,3,0,0,563,73,1,0,0,0,564,565,5,2,0,
  	0,565,569,3,14,7,0,566,568,3,72,36,0,567,566,1,0,0,0,568,571,1,0,0,0,
  	569,567,1,0,0,0,569,570,1,0,0,0,570,572,1,0,0,0,571,569,1,0,0,0,572,573,
  	5,3,0,0,573,75,1,0,0,0,574,576,5,2,0,0,575,577,3,74,37,0,576,575,1,0,
  	0,0,577,578,1,0,0,0,578,576,1,0,0,0,578,579,1,0,0,0,579,580,1,0,0,0,580,
  	581,5,3,0,0,581,601,1,0,0,0,582,583,5,2,0,0,583,584,5,64,0,0,584,586,
  	5,2,0,0,585,587,3,14,7,0,586,585,1,0,0,0,587,588,1,0,0,0,588,586,1,0,
  	0,0,588,589,1,0,0,0,589,590,1,0,0,0,590,591,5,3,0,0,591,593,5,2,0,0,592,
  	594,3,74,37,0,593,592,1,0,0,0,594,595,1,0,0,0,595,593,1,0,0,0,595,596,
  	1,0,0,0,596,597,1,0,0,0,597,598,5,3,0,0,598,599,5,3,0,0,599,601,1,0,0,
  	0,600,574,1,0,0,0,600,582,1,0,0,0,601,77,1,0,0,0,602,603,5,2,0,0,603,
  	604,3,14,7,0,604,608,5,2,0,0,605,607,3,46,23,0,606,605,1,0,0,0,607,610,
  	1,0,0,0,608,606,1,0,0,0,608,609,1,0,0,0,609,611,1,0,0,0,610,608,1,0,0,
  	0,611,612,5,3,0,0,612,613,3,40,20,0,613,614,5,3,0,0,614,79,1,0,0,0,615,
  	616,3,14,7,0,616,620,5,2,0,0,617,619,3,46,23,0,618,617,1,0,0,0,619,622,
  	1,0,0,0,620,618,1,0,0,0,620,621,1,0,0,0,621,623,1,0,0,0,622,620,1,0,0,
  	0,623,624,5,3,0,0,624,625,3,40,20,0,625,626,3,52,26,0,626,81,1,0,0,0,
  	627,634,3,14,7,0,628,629,5,2,0,0,629,630,5,7,0,0,630,631,3,14,7,0,631,
  	632,5,3,0,0,632,634,1,0,0,0,633,627,1,0,0,0,633,628,1,0,0,0,634,83,1,
  	0,0,0,635,637,3,146,73,0,636,635,1,0,0,0,637,640,1,0,0,0,638,636,1,0,
  	0,0,638,639,1,0,0,0,639,85,1,0,0,0,640,638,1,0,0,0,641,642,5,23,0,0,642,
  	87,1,0,0,0,643,644,5,24,0,0,644,89,1,0,0,0,645,646,5,25,0,0,646,91,1,
  	0,0,0,647,648,5,26,0,0,648,93,1,0,0,0,649,650,5,27,0,0,650,95,1,0,0,0,
  	651,652,5,28,0,0,652,97,1,0,0,0,653,654,5,29,0,0,654,99,1,0,0,0,655,656,
  	5,30,0,0,656,101,1,0,0,0,657,658,5,31,0,0,658,103,1,0,0,0,659,660,5,32,
  	0,0,660,105,1,0,0,0,661,662,5,33,0,0,662,107,1,0,0,0,663,664,5,34,0,0,
  	664,109,1,0,0,0,665,666,5,35,0,0,666,111,1,0,0,0,667,668,5,36,0,0,668,
  	113,1,0,0,0,669,670,5,37,0,0,670,115,1,0,0,0,671,672,5,38,0,0,672,117,
  	1,0,0,0,673,674,5,39,0,0,674,119,1,0,0,0,675,676,5,40,0,0,676,121,1,0,
  	0,0,677,678,5,41,0,0,678,123,1,0,0,0,679,680,5,42,0,0,680,125,1,0,0,0,
  	681,682,5,43,0,0,682,127,1,0,0,0,683,684,5,44,0,0,684,129,1,0,0,0,685,
  	686,5,45,0,0,686,131,1,0,0,0,687,688,5,46,0,0,688,133,1,0,0,0,689,690,
  	5,47,0,0,690,135,1,0,0,0,691,692,5,48,0,0,692,137,1,0,0,0,693,694,5,49,
  	0,0,694,139,1,0,0,0,695,696,5,50,0,0,696,141,1,0,0,0,697,698,5,51,0,0,
  	698,143,1,0,0,0,699,700,5,52,0,0,700,145,1,0,0,0,701,702,5,2,0,0,702,
  	703,3,86,43,0,703,704,3,52,26,0,704,705,5,3,0,0,705,894,1,0,0,0,706,707,
  	5,2,0,0,707,708,3,88,44,0,708,709,5,3,0,0,709,894,1,0,0,0,710,711,5,2,
  	0,0,711,712,3,90,45,0,712,713,5,3,0,0,713,894,1,0,0,0,714,715,5,2,0,0,
  	715,716,3,92,46,0,716,717,3,14,7,0,717,718,3,40,20,0,718,719,5,3,0,0,
  	719,894,1,0,0,0,720,721,5,2,0,0,721,722,3,94,47,0,722,723,3,14,7,0,723,
  	724,3,76,38,0,724,725,5,3,0,0,725,894,1,0,0,0,726,727,5,2,0,0,727,728,
  	3,96,48,0,728,730,5,2,0,0,729,731,3,70,35,0,730,729,1,0,0,0,731,732,1,
  	0,0,0,732,730,1,0,0,0,732,733,1,0,0,0,733,734,1,0,0,0,734,735,5,3,0,0,
  	735,737,5,2,0,0,736,738,3,76,38,0,737,736,1,0,0,0,738,739,1,0,0,0,739,
  	737,1,0,0,0,739,740,1,0,0,0,740,741,1,0,0,0,741,742,5,3,0,0,742,743,5,
  	3,0,0,743,894,1,0,0,0,744,745,5,2,0,0,745,746,3,98,49,0,746,747,3,14,
  	7,0,747,751,5,2,0,0,748,750,3,40,20,0,749,748,1,0,0,0,750,753,1,0,0,0,
  	751,749,1,0,0,0,751,752,1,0,0,0,752,754,1,0,0,0,753,751,1,0,0,0,754,755,
  	5,3,0,0,755,756,3,40,20,0,756,757,5,3,0,0,757,894,1,0,0,0,758,759,5,2,
  	0,0,759,760,3,100,50,0,760,761,3,14,7,0,761,762,3,16,8,0,762,763,5,3,
  	0,0,763,894,1,0,0,0,764,765,5,2,0,0,765,766,3,102,51,0,766,767,3,80,40,
  	0,767,768,5,3,0,0,768,894,1,0,0,0,769,770,5,2,0,0,770,771,3,104,52,0,
  	771,772,3,80,40,0,772,773,5,3,0,0,773,894,1,0,0,0,774,775,5,2,0,0,775,
  	776,3,106,53,0,776,778,5,2,0,0,777,779,3,78,39,0,778,777,1,0,0,0,779,
  	780,1,0,0,0,780,778,1,0,0,0,780,781,1,0,0,0,781,782,1,0,0,0,782,783,5,
  	3,0,0,783,785,5,2,0,0,784,786,3,52,26,0,785,784,1,0,0,0,786,787,1,0,0,
  	0,787,785,1,0,0,0,787,788,1,0,0,0,788,789,1,0,0,0,789,790,5,3,0,0,790,
  	791,5,3,0,0,791,894,1,0,0,0,792,793,5,2,0,0,793,794,3,108,54,0,794,795,
  	3,14,7,0,795,799,5,2,0,0,796,798,3,14,7,0,797,796,1,0,0,0,798,801,1,0,
  	0,0,799,797,1,0,0,0,799,800,1,0,0,0,800,802,1,0,0,0,801,799,1,0,0,0,802,
  	803,5,3,0,0,803,804,3,40,20,0,804,805,5,3,0,0,805,894,1,0,0,0,806,807,
  	5,2,0,0,807,808,3,110,55,0,808,809,3,24,12,0,809,810,5,3,0,0,810,894,
  	1,0,0,0,811,812,5,2,0,0,812,813,3,112,56,0,813,814,5,3,0,0,814,894,1,
  	0,0,0,815,816,5,2,0,0,816,817,3,114,57,0,817,818,5,3,0,0,818,894,1,0,
  	0,0,819,820,5,2,0,0,820,821,3,116,58,0,821,822,5,3,0,0,822,894,1,0,0,
  	0,823,824,5,2,0,0,824,825,3,118,59,0,825,826,3,152,76,0,826,827,5,3,0,
  	0,827,894,1,0,0,0,828,829,5,2,0,0,829,830,3,120,60,0,830,831,5,3,0,0,
  	831,894,1,0,0,0,832,833,5,2,0,0,833,834,3,122,61,0,834,835,3,26,13,0,
  	835,836,5,3,0,0,836,894,1,0,0,0,837,838,5,2,0,0,838,839,3,124,62,0,839,
  	840,5,3,0,0,840,894,1,0,0,0,841,842,5,2,0,0,842,843,3,126,63,0,843,844,
  	5,3,0,0,844,894,1,0,0,0,845,846,5,2,0,0,846,847,3,128,64,0,847,848,5,
  	3,0,0,848,894,1,0,0,0,849,850,5,2,0,0,850,851,3,130,65,0,851,853,5,2,
  	0,0,852,854,3,52,26,0,853,852,1,0,0,0,854,855,1,0,0,0,855,853,1,0,0,0,
  	855,856,1,0,0,0,856,857,1,0,0,0,857,858,5,3,0,0,858,859,5,3,0,0,859,894,
  	1,0,0,0,860,861,5,2,0,0,861,862,3,132,66,0,862,863,3,16,8,0,863,864,5,
  	3,0,0,864,894,1,0,0,0,865,866,5,2,0,0,866,867,3,134,67,0,867,868,3,16,
  	8,0,868,869,5,3,0,0,869,894,1,0,0,0,870,871,5,2,0,0,871,872,3,136,68,
  	0,872,873,5,3,0,0,873,894,1,0,0,0,874,875,5,2,0,0,875,876,3,138,69,0,
  	876,877,5,3,0,0,877,894,1,0,0,0,878,879,5,2,0,0,879,880,3,140,70,0,880,
  	881,3,38,19,0,881,882,5,3,0,0,882,894,1,0,0,0,883,884,5,2,0,0,884,885,
  	3,142,71,0,885,886,3,14,7,0,886,887,5,3,0,0,887,894,1,0,0,0,888,889,5,
  	2,0,0,889,890,3,144,72,0,890,891,3,150,75,0,891,892,5,3,0,0,892,894,1,
  	0,0,0,893,701,1,0,0,0,893,706,1,0,0,0,893,710,1,0,0,0,893,714,1,0,0,0,
  	893,720,1,0,0,0,893,726,1,0,0,0,893,744,1,0,0,0,893,758,1,0,0,0,893,764,
  	1,0,0,0,893,769,1,0,0,0,893,774,1,0,0,0,893,792,1,0,0,0,893,806,1,0,0,
  	0,893,811,1,0,0,0,893,815,1,0,0,0,893,819,1,0,0,0,893,823,1,0,0,0,893,
  	828,1,0,0,0,893,832,1,0,0,0,893,837,1,0,0,0,893,841,1,0,0,0,893,845,1,
  	0,0,0,893,849,1,0,0,0,893,860,1,0,0,0,893,865,1,0,0,0,893,870,1,0,0,0,
  	893,874,1,0,0,0,893,878,1,0,0,0,893,883,1,0,0,0,893,888,1,0,0,0,894,147,
  	1,0,0,0,895,896,7,4,0,0,896,149,1,0,0,0,897,898,5,77,0,0,898,927,3,24,
  	12,0,899,900,5,82,0,0,900,927,3,148,74,0,901,902,5,83,0,0,902,927,3,148,
  	74,0,903,904,5,91,0,0,904,927,3,148,74,0,905,906,5,92,0,0,906,927,3,148,
  	74,0,907,908,5,93,0,0,908,927,3,148,74,0,909,910,5,94,0,0,910,927,3,148,
  	74,0,911,912,5,95,0,0,912,927,3,148,74,0,913,914,5,96,0,0,914,927,3,148,
  	74,0,915,916,5,97,0,0,916,927,3,148,74,0,917,918,5,98,0,0,918,927,3,16,
  	8,0,919,920,5,100,0,0,920,927,3,24,12,0,921,922,5,101,0,0,922,927,3,16,
  	8,0,923,924,5,110,0,0,924,927,3,16,8,0,925,927,3,38,19,0,926,897,1,0,
  	0,0,926,899,1,0,0,0,926,901,1,0,0,0,926,903,1,0,0,0,926,905,1,0,0,0,926,
  	907,1,0,0,0,926,909,1,0,0,0,926,911,1,0,0,0,926,913,1,0,0,0,926,915,1,
  	0,0,0,926,917,1,0,0,0,926,919,1,0,0,0,926,921,1,0,0,0,926,923,1,0,0,0,
  	926,925,1,0,0,0,927,151,1,0,0,0,928,937,5,71,0,0,929,937,5,72,0,0,930,
  	937,5,73,0,0,931,937,5,78,0,0,932,937,5,88,0,0,933,937,5,99,0,0,934,937,
  	5,111,0,0,935,937,3,26,13,0,936,928,1,0,0,0,936,929,1,0,0,0,936,930,1,
  	0,0,0,936,931,1,0,0,0,936,932,1,0,0,0,936,933,1,0,0,0,936,934,1,0,0,0,
  	936,935,1,0,0,0,937,153,1,0,0,0,938,939,7,5,0,0,939,155,1,0,0,0,940,944,
  	5,15,0,0,941,944,5,13,0,0,942,944,3,30,15,0,943,940,1,0,0,0,943,941,1,
  	0,0,0,943,942,1,0,0,0,944,157,1,0,0,0,945,946,5,2,0,0,946,947,5,31,0,
  	0,947,948,3,80,40,0,948,949,5,3,0,0,949,974,1,0,0,0,950,951,5,2,0,0,951,
  	952,5,32,0,0,952,953,3,80,40,0,953,954,5,3,0,0,954,974,1,0,0,0,955,956,
  	5,2,0,0,956,957,5,33,0,0,957,959,5,2,0,0,958,960,3,78,39,0,959,958,1,
  	0,0,0,960,961,1,0,0,0,961,959,1,0,0,0,961,962,1,0,0,0,962,963,1,0,0,0,
  	963,964,5,3,0,0,964,966,5,2,0,0,965,967,3,52,26,0,966,965,1,0,0,0,967,
  	968,1,0,0,0,968,966,1,0,0,0,968,969,1,0,0,0,969,970,1,0,0,0,970,971,5,
  	3,0,0,971,972,5,3,0,0,972,974,1,0,0,0,973,945,1,0,0,0,973,950,1,0,0,0,
  	973,955,1,0,0,0,974,159,1,0,0,0,975,976,5,72,0,0,976,989,3,16,8,0,977,
  	978,5,73,0,0,978,989,3,24,12,0,979,980,5,78,0,0,980,989,3,154,77,0,981,
  	982,5,88,0,0,982,989,3,24,12,0,983,984,5,99,0,0,984,989,3,156,78,0,985,
  	986,5,111,0,0,986,989,3,24,12,0,987,989,3,38,19,0,988,975,1,0,0,0,988,
  	977,1,0,0,0,988,979,1,0,0,0,988,981,1,0,0,0,988,983,1,0,0,0,988,985,1,
  	0,0,0,988,987,1,0,0,0,989,161,1,0,0,0,990,991,5,2,0,0,991,992,3,52,26,
  	0,992,993,3,52,26,0,993,994,5,3,0,0,994,163,1,0,0,0,995,996,5,2,0,0,996,
  	997,3,14,7,0,997,998,3,148,74,0,998,999,5,3,0,0,999,165,1,0,0,0,1000,
  	1001,7,6,0,0,1001,167,1,0,0,0,1002,1003,3,24,12,0,1003,169,1,0,0,0,1004,
  	1008,5,2,0,0,1005,1007,3,52,26,0,1006,1005,1,0,0,0,1007,1010,1,0,0,0,
  	1008,1006,1,0,0,0,1008,1009,1,0,0,0,1009,1011,1,0,0,0,1010,1008,1,0,0,
  	0,1011,1012,5,3,0,0,1012,171,1,0,0,0,1013,1017,5,2,0,0,1014,1016,3,164,
  	82,0,1015,1014,1,0,0,0,1016,1019,1,0,0,0,1017,1015,1,0,0,0,1017,1018,
  	1,0,0,0,1018,1020,1,0,0,0,1019,1017,1,0,0,0,1020,1021,5,3,0,0,1021,173,
  	1,0,0,0,1022,1024,5,2,0,0,1023,1025,3,160,80,0,1024,1023,1,0,0,0,1025,
  	1026,1,0,0,0,1026,1024,1,0,0,0,1026,1027,1,0,0,0,1027,1028,1,0,0,0,1028,
  	1029,5,3,0,0,1029,175,1,0,0,0,1030,1034,5,2,0,0,1031,1033,3,158,79,0,
  	1032,1031,1,0,0,0,1033,1036,1,0,0,0,1034,1032,1,0,0,0,1034,1035,1,0,0,
  	0,1035,1037,1,0,0,0,1036,1034,1,0,0,0,1037,1038,5,3,0,0,1038,177,1,0,
  	0,0,1039,1040,3,36,18,0,1040,179,1,0,0,0,1041,1042,3,30,15,0,1042,181,
  	1,0,0,0,1043,1047,5,2,0,0,1044,1046,3,14,7,0,1045,1044,1,0,0,0,1046,1049,
  	1,0,0,0,1047,1045,1,0,0,0,1047,1048,1,0,0,0,1048,1050,1,0,0,0,1049,1047,
  	1,0,0,0,1050,1051,5,3,0,0,1051,183,1,0,0,0,1052,1056,5,2,0,0,1053,1055,
  	3,14,7,0,1054,1053,1,0,0,0,1055,1058,1,0,0,0,1056,1054,1,0,0,0,1056,1057,
  	1,0,0,0,1057,1059,1,0,0,0,1058,1056,1,0,0,0,1059,1060,5,3,0,0,1060,185,
  	1,0,0,0,1061,1063,5,2,0,0,1062,1064,3,162,81,0,1063,1062,1,0,0,0,1064,
  	1065,1,0,0,0,1065,1063,1,0,0,0,1065,1066,1,0,0,0,1066,1067,1,0,0,0,1067,
  	1068,5,3,0,0,1068,187,1,0,0,0,1069,1081,3,166,83,0,1070,1081,3,168,84,
  	0,1071,1081,3,170,85,0,1072,1081,3,172,86,0,1073,1081,3,174,87,0,1074,
  	1081,3,176,88,0,1075,1081,3,178,89,0,1076,1081,3,180,90,0,1077,1081,3,
  	182,91,0,1078,1081,3,184,92,0,1079,1081,3,186,93,0,1080,1069,1,0,0,0,
  	1080,1070,1,0,0,0,1080,1071,1,0,0,0,1080,1072,1,0,0,0,1080,1073,1,0,0,
  	0,1080,1074,1,0,0,0,1080,1075,1,0,0,0,1080,1076,1,0,0,0,1080,1077,1,0,
  	0,0,1080,1078,1,0,0,0,1080,1079,1,0,0,0,1081,189,1,0,0,0,1082,1091,5,
  	17,0,0,1083,1091,3,188,94,0,1084,1091,5,21,0,0,1085,1086,5,2,0,0,1086,
  	1087,5,10,0,0,1087,1088,3,24,12,0,1088,1089,5,3,0,0,1089,1091,1,0,0,0,
  	1090,1082,1,0,0,0,1090,1083,1,0,0,0,1090,1084,1,0,0,0,1090,1085,1,0,0,
  	0,1091,191,1,0,0,0,74,202,212,227,234,243,247,251,260,264,272,276,282,
  	290,294,303,321,325,339,349,361,373,386,397,401,409,422,433,443,448,453,
  	462,470,475,481,488,497,512,520,529,542,550,569,578,588,595,600,608,620,
  	633,638,732,739,751,780,787,799,855,893,926,936,943,961,968,973,988,1008,
  	1017,1026,1034,1047,1056,1065,1080,1090
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  smtlibv2ParserStaticData = staticData.release();
}

}

SMTLIBv2Parser::SMTLIBv2Parser(TokenStream *input) : SMTLIBv2Parser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

SMTLIBv2Parser::SMTLIBv2Parser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  SMTLIBv2Parser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *smtlibv2ParserStaticData->atn, smtlibv2ParserStaticData->decisionToDFA, smtlibv2ParserStaticData->sharedContextCache, options);
}

SMTLIBv2Parser::~SMTLIBv2Parser() {
  delete _interpreter;
}

const atn::ATN& SMTLIBv2Parser::getATN() const {
  return *smtlibv2ParserStaticData->atn;
}

std::string SMTLIBv2Parser::getGrammarFileName() const {
  return "SMTLIBv2.g4";
}

const std::vector<std::string>& SMTLIBv2Parser::getRuleNames() const {
  return smtlibv2ParserStaticData->ruleNames;
}

const dfa::Vocabulary& SMTLIBv2Parser::getVocabulary() const {
  return smtlibv2ParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView SMTLIBv2Parser::getSerializedATN() const {
  return smtlibv2ParserStaticData->serializedATN;
}


//----------------- StartContext ------------------------------------------------------------------

SMTLIBv2Parser::StartContext::StartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::ScriptContext* SMTLIBv2Parser::StartContext::script() {
  return getRuleContext<SMTLIBv2Parser::ScriptContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::StartContext::EOF() {
  return getToken(SMTLIBv2Parser::EOF, 0);
}


size_t SMTLIBv2Parser::StartContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleStart;
}

void SMTLIBv2Parser::StartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStart(this);
}

void SMTLIBv2Parser::StartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStart(this);
}


std::any SMTLIBv2Parser::StartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitStart(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::StartContext* SMTLIBv2Parser::start() {
  StartContext *_localctx = _tracker.createInstance<StartContext>(_ctx, getState());
  enterRule(_localctx, 0, SMTLIBv2Parser::RuleStart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(192);
    script();
    setState(193);
    match(SMTLIBv2Parser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResponseContext ------------------------------------------------------------------

SMTLIBv2Parser::ResponseContext::ResponseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::General_responseContext* SMTLIBv2Parser::ResponseContext::general_response() {
  return getRuleContext<SMTLIBv2Parser::General_responseContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::ResponseContext::EOF() {
  return getToken(SMTLIBv2Parser::EOF, 0);
}


size_t SMTLIBv2Parser::ResponseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleResponse;
}

void SMTLIBv2Parser::ResponseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResponse(this);
}

void SMTLIBv2Parser::ResponseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResponse(this);
}


std::any SMTLIBv2Parser::ResponseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitResponse(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::ResponseContext* SMTLIBv2Parser::response() {
  ResponseContext *_localctx = _tracker.createInstance<ResponseContext>(_ctx, getState());
  enterRule(_localctx, 2, SMTLIBv2Parser::RuleResponse);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(195);
    general_response();
    setState(196);
    match(SMTLIBv2Parser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneralReservedWordContext ------------------------------------------------------------------

SMTLIBv2Parser::GeneralReservedWordContext::GeneralReservedWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Exclamation() {
  return getToken(SMTLIBv2Parser::GRW_Exclamation, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Underscore() {
  return getToken(SMTLIBv2Parser::GRW_Underscore, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_As() {
  return getToken(SMTLIBv2Parser::GRW_As, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Binary() {
  return getToken(SMTLIBv2Parser::GRW_Binary, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Decimal() {
  return getToken(SMTLIBv2Parser::GRW_Decimal, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Exists() {
  return getToken(SMTLIBv2Parser::GRW_Exists, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Hexadecimal() {
  return getToken(SMTLIBv2Parser::GRW_Hexadecimal, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Forall() {
  return getToken(SMTLIBv2Parser::GRW_Forall, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Let() {
  return getToken(SMTLIBv2Parser::GRW_Let, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Match() {
  return getToken(SMTLIBv2Parser::GRW_Match, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Numeral() {
  return getToken(SMTLIBv2Parser::GRW_Numeral, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_Par() {
  return getToken(SMTLIBv2Parser::GRW_Par, 0);
}

tree::TerminalNode* SMTLIBv2Parser::GeneralReservedWordContext::GRW_String() {
  return getToken(SMTLIBv2Parser::GRW_String, 0);
}


size_t SMTLIBv2Parser::GeneralReservedWordContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGeneralReservedWord;
}

void SMTLIBv2Parser::GeneralReservedWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneralReservedWord(this);
}

void SMTLIBv2Parser::GeneralReservedWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneralReservedWord(this);
}


std::any SMTLIBv2Parser::GeneralReservedWordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGeneralReservedWord(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::GeneralReservedWordContext* SMTLIBv2Parser::generalReservedWord() {
  GeneralReservedWordContext *_localctx = _tracker.createInstance<GeneralReservedWordContext>(_ctx, getState());
  enterRule(_localctx, 4, SMTLIBv2Parser::RuleGeneralReservedWord);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(198);
    _la = _input->LA(1);
    if (!(((((_la - 53) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 53)) & 8191) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleSymbolContext ------------------------------------------------------------------

SMTLIBv2Parser::SimpleSymbolContext::SimpleSymbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::PredefSymbolContext* SMTLIBv2Parser::SimpleSymbolContext::predefSymbol() {
  return getRuleContext<SMTLIBv2Parser::PredefSymbolContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::SimpleSymbolContext::UndefinedSymbol() {
  return getToken(SMTLIBv2Parser::UndefinedSymbol, 0);
}


size_t SMTLIBv2Parser::SimpleSymbolContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSimpleSymbol;
}

void SMTLIBv2Parser::SimpleSymbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleSymbol(this);
}

void SMTLIBv2Parser::SimpleSymbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleSymbol(this);
}


std::any SMTLIBv2Parser::SimpleSymbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSimpleSymbol(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::SimpleSymbolContext* SMTLIBv2Parser::simpleSymbol() {
  SimpleSymbolContext *_localctx = _tracker.createInstance<SimpleSymbolContext>(_ctx, getState());
  enterRule(_localctx, 6, SMTLIBv2Parser::RuleSimpleSymbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(202);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::PS_Not:
      case SMTLIBv2Parser::PS_Bool:
      case SMTLIBv2Parser::PS_ContinuedExecution:
      case SMTLIBv2Parser::PS_Error:
      case SMTLIBv2Parser::PS_False:
      case SMTLIBv2Parser::PS_ImmediateExit:
      case SMTLIBv2Parser::PS_Incomplete:
      case SMTLIBv2Parser::PS_Logic:
      case SMTLIBv2Parser::PS_Memout:
      case SMTLIBv2Parser::PS_Sat:
      case SMTLIBv2Parser::PS_Success:
      case SMTLIBv2Parser::PS_Theory:
      case SMTLIBv2Parser::PS_True:
      case SMTLIBv2Parser::PS_Unknown:
      case SMTLIBv2Parser::PS_Unsupported:
      case SMTLIBv2Parser::PS_Unsat: {
        enterOuterAlt(_localctx, 1);
        setState(200);
        predefSymbol();
        break;
      }

      case SMTLIBv2Parser::UndefinedSymbol: {
        enterOuterAlt(_localctx, 2);
        setState(201);
        match(SMTLIBv2Parser::UndefinedSymbol);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuotedSymbolContext ------------------------------------------------------------------

SMTLIBv2Parser::QuotedSymbolContext::QuotedSymbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::QuotedSymbolContext::QuotedSymbol() {
  return getToken(SMTLIBv2Parser::QuotedSymbol, 0);
}


size_t SMTLIBv2Parser::QuotedSymbolContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleQuotedSymbol;
}

void SMTLIBv2Parser::QuotedSymbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuotedSymbol(this);
}

void SMTLIBv2Parser::QuotedSymbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuotedSymbol(this);
}


std::any SMTLIBv2Parser::QuotedSymbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitQuotedSymbol(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::QuotedSymbolContext* SMTLIBv2Parser::quotedSymbol() {
  QuotedSymbolContext *_localctx = _tracker.createInstance<QuotedSymbolContext>(_ctx, getState());
  enterRule(_localctx, 8, SMTLIBv2Parser::RuleQuotedSymbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(204);
    match(SMTLIBv2Parser::QuotedSymbol);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredefSymbolContext ------------------------------------------------------------------

SMTLIBv2Parser::PredefSymbolContext::PredefSymbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Not() {
  return getToken(SMTLIBv2Parser::PS_Not, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Bool() {
  return getToken(SMTLIBv2Parser::PS_Bool, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_ContinuedExecution() {
  return getToken(SMTLIBv2Parser::PS_ContinuedExecution, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Error() {
  return getToken(SMTLIBv2Parser::PS_Error, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_False() {
  return getToken(SMTLIBv2Parser::PS_False, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_ImmediateExit() {
  return getToken(SMTLIBv2Parser::PS_ImmediateExit, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Incomplete() {
  return getToken(SMTLIBv2Parser::PS_Incomplete, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Logic() {
  return getToken(SMTLIBv2Parser::PS_Logic, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Memout() {
  return getToken(SMTLIBv2Parser::PS_Memout, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Sat() {
  return getToken(SMTLIBv2Parser::PS_Sat, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Success() {
  return getToken(SMTLIBv2Parser::PS_Success, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Theory() {
  return getToken(SMTLIBv2Parser::PS_Theory, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_True() {
  return getToken(SMTLIBv2Parser::PS_True, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Unknown() {
  return getToken(SMTLIBv2Parser::PS_Unknown, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Unsupported() {
  return getToken(SMTLIBv2Parser::PS_Unsupported, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefSymbolContext::PS_Unsat() {
  return getToken(SMTLIBv2Parser::PS_Unsat, 0);
}


size_t SMTLIBv2Parser::PredefSymbolContext::getRuleIndex() const {
  return SMTLIBv2Parser::RulePredefSymbol;
}

void SMTLIBv2Parser::PredefSymbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredefSymbol(this);
}

void SMTLIBv2Parser::PredefSymbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredefSymbol(this);
}


std::any SMTLIBv2Parser::PredefSymbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitPredefSymbol(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::PredefSymbolContext* SMTLIBv2Parser::predefSymbol() {
  PredefSymbolContext *_localctx = _tracker.createInstance<PredefSymbolContext>(_ctx, getState());
  enterRule(_localctx, 10, SMTLIBv2Parser::RulePredefSymbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(206);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8388480) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredefKeywordContext ------------------------------------------------------------------

SMTLIBv2Parser::PredefKeywordContext::PredefKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_AllStatistics() {
  return getToken(SMTLIBv2Parser::PK_AllStatistics, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_AssertionStackLevels() {
  return getToken(SMTLIBv2Parser::PK_AssertionStackLevels, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Authors() {
  return getToken(SMTLIBv2Parser::PK_Authors, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Category() {
  return getToken(SMTLIBv2Parser::PK_Category, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Chainable() {
  return getToken(SMTLIBv2Parser::PK_Chainable, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Definition() {
  return getToken(SMTLIBv2Parser::PK_Definition, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_DiagnosticOutputChannel() {
  return getToken(SMTLIBv2Parser::PK_DiagnosticOutputChannel, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ErrorBehaviour() {
  return getToken(SMTLIBv2Parser::PK_ErrorBehaviour, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Extension() {
  return getToken(SMTLIBv2Parser::PK_Extension, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Funs() {
  return getToken(SMTLIBv2Parser::PK_Funs, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_FunsDescription() {
  return getToken(SMTLIBv2Parser::PK_FunsDescription, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_GlobalDeclarations() {
  return getToken(SMTLIBv2Parser::PK_GlobalDeclarations, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_InteractiveMode() {
  return getToken(SMTLIBv2Parser::PK_InteractiveMode, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Language() {
  return getToken(SMTLIBv2Parser::PK_Language, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_LeftAssoc() {
  return getToken(SMTLIBv2Parser::PK_LeftAssoc, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_License() {
  return getToken(SMTLIBv2Parser::PK_License, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Named() {
  return getToken(SMTLIBv2Parser::PK_Named, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Name() {
  return getToken(SMTLIBv2Parser::PK_Name, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Notes() {
  return getToken(SMTLIBv2Parser::PK_Notes, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Pattern() {
  return getToken(SMTLIBv2Parser::PK_Pattern, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_PrintSuccess() {
  return getToken(SMTLIBv2Parser::PK_PrintSuccess, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ProduceAssertions() {
  return getToken(SMTLIBv2Parser::PK_ProduceAssertions, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ProduceAssignments() {
  return getToken(SMTLIBv2Parser::PK_ProduceAssignments, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ProduceModels() {
  return getToken(SMTLIBv2Parser::PK_ProduceModels, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ProduceProofs() {
  return getToken(SMTLIBv2Parser::PK_ProduceProofs, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ProduceUnsatAssumptions() {
  return getToken(SMTLIBv2Parser::PK_ProduceUnsatAssumptions, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ProduceUnsatCores() {
  return getToken(SMTLIBv2Parser::PK_ProduceUnsatCores, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_RandomSeed() {
  return getToken(SMTLIBv2Parser::PK_RandomSeed, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ReasonUnknown() {
  return getToken(SMTLIBv2Parser::PK_ReasonUnknown, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_RegularOutputChannel() {
  return getToken(SMTLIBv2Parser::PK_RegularOutputChannel, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_ReproducibleResourceLimit() {
  return getToken(SMTLIBv2Parser::PK_ReproducibleResourceLimit, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_RightAssoc() {
  return getToken(SMTLIBv2Parser::PK_RightAssoc, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_SmtLibVersion() {
  return getToken(SMTLIBv2Parser::PK_SmtLibVersion, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Sorts() {
  return getToken(SMTLIBv2Parser::PK_Sorts, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_SortsDescription() {
  return getToken(SMTLIBv2Parser::PK_SortsDescription, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Source() {
  return getToken(SMTLIBv2Parser::PK_Source, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Status() {
  return getToken(SMTLIBv2Parser::PK_Status, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Theories() {
  return getToken(SMTLIBv2Parser::PK_Theories, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Values() {
  return getToken(SMTLIBv2Parser::PK_Values, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Verbosity() {
  return getToken(SMTLIBv2Parser::PK_Verbosity, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PredefKeywordContext::PK_Version() {
  return getToken(SMTLIBv2Parser::PK_Version, 0);
}


size_t SMTLIBv2Parser::PredefKeywordContext::getRuleIndex() const {
  return SMTLIBv2Parser::RulePredefKeyword;
}

void SMTLIBv2Parser::PredefKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredefKeyword(this);
}

void SMTLIBv2Parser::PredefKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredefKeyword(this);
}


std::any SMTLIBv2Parser::PredefKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitPredefKeyword(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::PredefKeywordContext* SMTLIBv2Parser::predefKeyword() {
  PredefKeywordContext *_localctx = _tracker.createInstance<PredefKeywordContext>(_ctx, getState());
  enterRule(_localctx, 12, SMTLIBv2Parser::RulePredefKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(208);
    _la = _input->LA(1);
    if (!(((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & 2199023255551) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolContext ------------------------------------------------------------------

SMTLIBv2Parser::SymbolContext::SymbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::SimpleSymbolContext* SMTLIBv2Parser::SymbolContext::simpleSymbol() {
  return getRuleContext<SMTLIBv2Parser::SimpleSymbolContext>(0);
}

SMTLIBv2Parser::QuotedSymbolContext* SMTLIBv2Parser::SymbolContext::quotedSymbol() {
  return getRuleContext<SMTLIBv2Parser::QuotedSymbolContext>(0);
}


size_t SMTLIBv2Parser::SymbolContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSymbol;
}

void SMTLIBv2Parser::SymbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbol(this);
}

void SMTLIBv2Parser::SymbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbol(this);
}


std::any SMTLIBv2Parser::SymbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSymbol(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::symbol() {
  SymbolContext *_localctx = _tracker.createInstance<SymbolContext>(_ctx, getState());
  enterRule(_localctx, 14, SMTLIBv2Parser::RuleSymbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(212);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::PS_Not:
      case SMTLIBv2Parser::PS_Bool:
      case SMTLIBv2Parser::PS_ContinuedExecution:
      case SMTLIBv2Parser::PS_Error:
      case SMTLIBv2Parser::PS_False:
      case SMTLIBv2Parser::PS_ImmediateExit:
      case SMTLIBv2Parser::PS_Incomplete:
      case SMTLIBv2Parser::PS_Logic:
      case SMTLIBv2Parser::PS_Memout:
      case SMTLIBv2Parser::PS_Sat:
      case SMTLIBv2Parser::PS_Success:
      case SMTLIBv2Parser::PS_Theory:
      case SMTLIBv2Parser::PS_True:
      case SMTLIBv2Parser::PS_Unknown:
      case SMTLIBv2Parser::PS_Unsupported:
      case SMTLIBv2Parser::PS_Unsat:
      case SMTLIBv2Parser::UndefinedSymbol: {
        enterOuterAlt(_localctx, 1);
        setState(210);
        simpleSymbol();
        break;
      }

      case SMTLIBv2Parser::QuotedSymbol: {
        enterOuterAlt(_localctx, 2);
        setState(211);
        quotedSymbol();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumeralContext ------------------------------------------------------------------

SMTLIBv2Parser::NumeralContext::NumeralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::NumeralContext::Numeral() {
  return getToken(SMTLIBv2Parser::Numeral, 0);
}


size_t SMTLIBv2Parser::NumeralContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleNumeral;
}

void SMTLIBv2Parser::NumeralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumeral(this);
}

void SMTLIBv2Parser::NumeralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumeral(this);
}


std::any SMTLIBv2Parser::NumeralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitNumeral(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::NumeralContext* SMTLIBv2Parser::numeral() {
  NumeralContext *_localctx = _tracker.createInstance<NumeralContext>(_ctx, getState());
  enterRule(_localctx, 16, SMTLIBv2Parser::RuleNumeral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(214);
    match(SMTLIBv2Parser::Numeral);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecimalContext ------------------------------------------------------------------

SMTLIBv2Parser::DecimalContext::DecimalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::DecimalContext::Decimal() {
  return getToken(SMTLIBv2Parser::Decimal, 0);
}


size_t SMTLIBv2Parser::DecimalContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleDecimal;
}

void SMTLIBv2Parser::DecimalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecimal(this);
}

void SMTLIBv2Parser::DecimalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecimal(this);
}


std::any SMTLIBv2Parser::DecimalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitDecimal(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::DecimalContext* SMTLIBv2Parser::decimal() {
  DecimalContext *_localctx = _tracker.createInstance<DecimalContext>(_ctx, getState());
  enterRule(_localctx, 18, SMTLIBv2Parser::RuleDecimal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(216);
    match(SMTLIBv2Parser::Decimal);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HexadecimalContext ------------------------------------------------------------------

SMTLIBv2Parser::HexadecimalContext::HexadecimalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::HexadecimalContext::HexDecimal() {
  return getToken(SMTLIBv2Parser::HexDecimal, 0);
}


size_t SMTLIBv2Parser::HexadecimalContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleHexadecimal;
}

void SMTLIBv2Parser::HexadecimalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHexadecimal(this);
}

void SMTLIBv2Parser::HexadecimalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHexadecimal(this);
}


std::any SMTLIBv2Parser::HexadecimalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitHexadecimal(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::HexadecimalContext* SMTLIBv2Parser::hexadecimal() {
  HexadecimalContext *_localctx = _tracker.createInstance<HexadecimalContext>(_ctx, getState());
  enterRule(_localctx, 20, SMTLIBv2Parser::RuleHexadecimal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(218);
    match(SMTLIBv2Parser::HexDecimal);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryContext ------------------------------------------------------------------

SMTLIBv2Parser::BinaryContext::BinaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::BinaryContext::Binary() {
  return getToken(SMTLIBv2Parser::Binary, 0);
}


size_t SMTLIBv2Parser::BinaryContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleBinary;
}

void SMTLIBv2Parser::BinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinary(this);
}

void SMTLIBv2Parser::BinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinary(this);
}


std::any SMTLIBv2Parser::BinaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitBinary(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::BinaryContext* SMTLIBv2Parser::binary() {
  BinaryContext *_localctx = _tracker.createInstance<BinaryContext>(_ctx, getState());
  enterRule(_localctx, 22, SMTLIBv2Parser::RuleBinary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(220);
    match(SMTLIBv2Parser::Binary);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringContext ------------------------------------------------------------------

SMTLIBv2Parser::StringContext::StringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::StringContext::String() {
  return getToken(SMTLIBv2Parser::String, 0);
}


size_t SMTLIBv2Parser::StringContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleString;
}

void SMTLIBv2Parser::StringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterString(this);
}

void SMTLIBv2Parser::StringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitString(this);
}


std::any SMTLIBv2Parser::StringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitString(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::string() {
  StringContext *_localctx = _tracker.createInstance<StringContext>(_ctx, getState());
  enterRule(_localctx, 24, SMTLIBv2Parser::RuleString);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(222);
    match(SMTLIBv2Parser::String);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

SMTLIBv2Parser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::PredefKeywordContext* SMTLIBv2Parser::KeywordContext::predefKeyword() {
  return getRuleContext<SMTLIBv2Parser::PredefKeywordContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::KeywordContext::Colon() {
  return getToken(SMTLIBv2Parser::Colon, 0);
}

SMTLIBv2Parser::SimpleSymbolContext* SMTLIBv2Parser::KeywordContext::simpleSymbol() {
  return getRuleContext<SMTLIBv2Parser::SimpleSymbolContext>(0);
}


size_t SMTLIBv2Parser::KeywordContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleKeyword;
}

void SMTLIBv2Parser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void SMTLIBv2Parser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}


std::any SMTLIBv2Parser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitKeyword(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::KeywordContext* SMTLIBv2Parser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 26, SMTLIBv2Parser::RuleKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(227);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::PK_AllStatistics:
      case SMTLIBv2Parser::PK_AssertionStackLevels:
      case SMTLIBv2Parser::PK_Authors:
      case SMTLIBv2Parser::PK_Category:
      case SMTLIBv2Parser::PK_Chainable:
      case SMTLIBv2Parser::PK_Definition:
      case SMTLIBv2Parser::PK_DiagnosticOutputChannel:
      case SMTLIBv2Parser::PK_ErrorBehaviour:
      case SMTLIBv2Parser::PK_Extension:
      case SMTLIBv2Parser::PK_Funs:
      case SMTLIBv2Parser::PK_FunsDescription:
      case SMTLIBv2Parser::PK_GlobalDeclarations:
      case SMTLIBv2Parser::PK_InteractiveMode:
      case SMTLIBv2Parser::PK_Language:
      case SMTLIBv2Parser::PK_LeftAssoc:
      case SMTLIBv2Parser::PK_License:
      case SMTLIBv2Parser::PK_Named:
      case SMTLIBv2Parser::PK_Name:
      case SMTLIBv2Parser::PK_Notes:
      case SMTLIBv2Parser::PK_Pattern:
      case SMTLIBv2Parser::PK_PrintSuccess:
      case SMTLIBv2Parser::PK_ProduceAssertions:
      case SMTLIBv2Parser::PK_ProduceAssignments:
      case SMTLIBv2Parser::PK_ProduceModels:
      case SMTLIBv2Parser::PK_ProduceProofs:
      case SMTLIBv2Parser::PK_ProduceUnsatAssumptions:
      case SMTLIBv2Parser::PK_ProduceUnsatCores:
      case SMTLIBv2Parser::PK_RandomSeed:
      case SMTLIBv2Parser::PK_ReasonUnknown:
      case SMTLIBv2Parser::PK_RegularOutputChannel:
      case SMTLIBv2Parser::PK_ReproducibleResourceLimit:
      case SMTLIBv2Parser::PK_RightAssoc:
      case SMTLIBv2Parser::PK_SmtLibVersion:
      case SMTLIBv2Parser::PK_Sorts:
      case SMTLIBv2Parser::PK_SortsDescription:
      case SMTLIBv2Parser::PK_Source:
      case SMTLIBv2Parser::PK_Status:
      case SMTLIBv2Parser::PK_Theories:
      case SMTLIBv2Parser::PK_Values:
      case SMTLIBv2Parser::PK_Verbosity:
      case SMTLIBv2Parser::PK_Version: {
        enterOuterAlt(_localctx, 1);
        setState(224);
        predefKeyword();
        break;
      }

      case SMTLIBv2Parser::Colon: {
        enterOuterAlt(_localctx, 2);
        setState(225);
        match(SMTLIBv2Parser::Colon);
        setState(226);
        simpleSymbol();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Spec_constantContext ------------------------------------------------------------------

SMTLIBv2Parser::Spec_constantContext::Spec_constantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::NumeralContext* SMTLIBv2Parser::Spec_constantContext::numeral() {
  return getRuleContext<SMTLIBv2Parser::NumeralContext>(0);
}

SMTLIBv2Parser::DecimalContext* SMTLIBv2Parser::Spec_constantContext::decimal() {
  return getRuleContext<SMTLIBv2Parser::DecimalContext>(0);
}

SMTLIBv2Parser::HexadecimalContext* SMTLIBv2Parser::Spec_constantContext::hexadecimal() {
  return getRuleContext<SMTLIBv2Parser::HexadecimalContext>(0);
}

SMTLIBv2Parser::BinaryContext* SMTLIBv2Parser::Spec_constantContext::binary() {
  return getRuleContext<SMTLIBv2Parser::BinaryContext>(0);
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::Spec_constantContext::string() {
  return getRuleContext<SMTLIBv2Parser::StringContext>(0);
}


size_t SMTLIBv2Parser::Spec_constantContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSpec_constant;
}

void SMTLIBv2Parser::Spec_constantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpec_constant(this);
}

void SMTLIBv2Parser::Spec_constantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpec_constant(this);
}


std::any SMTLIBv2Parser::Spec_constantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSpec_constant(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Spec_constantContext* SMTLIBv2Parser::spec_constant() {
  Spec_constantContext *_localctx = _tracker.createInstance<Spec_constantContext>(_ctx, getState());
  enterRule(_localctx, 28, SMTLIBv2Parser::RuleSpec_constant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(234);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::Numeral: {
        enterOuterAlt(_localctx, 1);
        setState(229);
        numeral();
        break;
      }

      case SMTLIBv2Parser::Decimal: {
        enterOuterAlt(_localctx, 2);
        setState(230);
        decimal();
        break;
      }

      case SMTLIBv2Parser::HexDecimal: {
        enterOuterAlt(_localctx, 3);
        setState(231);
        hexadecimal();
        break;
      }

      case SMTLIBv2Parser::Binary: {
        enterOuterAlt(_localctx, 4);
        setState(232);
        binary();
        break;
      }

      case SMTLIBv2Parser::String: {
        enterOuterAlt(_localctx, 5);
        setState(233);
        string();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- S_exprContext ------------------------------------------------------------------

SMTLIBv2Parser::S_exprContext::S_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::Spec_constantContext* SMTLIBv2Parser::S_exprContext::spec_constant() {
  return getRuleContext<SMTLIBv2Parser::Spec_constantContext>(0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::S_exprContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

SMTLIBv2Parser::KeywordContext* SMTLIBv2Parser::S_exprContext::keyword() {
  return getRuleContext<SMTLIBv2Parser::KeywordContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::S_exprContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::S_exprContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::S_exprContext *> SMTLIBv2Parser::S_exprContext::s_expr() {
  return getRuleContexts<SMTLIBv2Parser::S_exprContext>();
}

SMTLIBv2Parser::S_exprContext* SMTLIBv2Parser::S_exprContext::s_expr(size_t i) {
  return getRuleContext<SMTLIBv2Parser::S_exprContext>(i);
}


size_t SMTLIBv2Parser::S_exprContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleS_expr;
}

void SMTLIBv2Parser::S_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterS_expr(this);
}

void SMTLIBv2Parser::S_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitS_expr(this);
}


std::any SMTLIBv2Parser::S_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitS_expr(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::S_exprContext* SMTLIBv2Parser::s_expr() {
  S_exprContext *_localctx = _tracker.createInstance<S_exprContext>(_ctx, getState());
  enterRule(_localctx, 30, SMTLIBv2Parser::RuleS_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(247);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::String:
      case SMTLIBv2Parser::Numeral:
      case SMTLIBv2Parser::Binary:
      case SMTLIBv2Parser::HexDecimal:
      case SMTLIBv2Parser::Decimal: {
        enterOuterAlt(_localctx, 1);
        setState(236);
        spec_constant();
        break;
      }

      case SMTLIBv2Parser::QuotedSymbol:
      case SMTLIBv2Parser::PS_Not:
      case SMTLIBv2Parser::PS_Bool:
      case SMTLIBv2Parser::PS_ContinuedExecution:
      case SMTLIBv2Parser::PS_Error:
      case SMTLIBv2Parser::PS_False:
      case SMTLIBv2Parser::PS_ImmediateExit:
      case SMTLIBv2Parser::PS_Incomplete:
      case SMTLIBv2Parser::PS_Logic:
      case SMTLIBv2Parser::PS_Memout:
      case SMTLIBv2Parser::PS_Sat:
      case SMTLIBv2Parser::PS_Success:
      case SMTLIBv2Parser::PS_Theory:
      case SMTLIBv2Parser::PS_True:
      case SMTLIBv2Parser::PS_Unknown:
      case SMTLIBv2Parser::PS_Unsupported:
      case SMTLIBv2Parser::PS_Unsat:
      case SMTLIBv2Parser::UndefinedSymbol: {
        enterOuterAlt(_localctx, 2);
        setState(237);
        symbol();
        break;
      }

      case SMTLIBv2Parser::Colon:
      case SMTLIBv2Parser::PK_AllStatistics:
      case SMTLIBv2Parser::PK_AssertionStackLevels:
      case SMTLIBv2Parser::PK_Authors:
      case SMTLIBv2Parser::PK_Category:
      case SMTLIBv2Parser::PK_Chainable:
      case SMTLIBv2Parser::PK_Definition:
      case SMTLIBv2Parser::PK_DiagnosticOutputChannel:
      case SMTLIBv2Parser::PK_ErrorBehaviour:
      case SMTLIBv2Parser::PK_Extension:
      case SMTLIBv2Parser::PK_Funs:
      case SMTLIBv2Parser::PK_FunsDescription:
      case SMTLIBv2Parser::PK_GlobalDeclarations:
      case SMTLIBv2Parser::PK_InteractiveMode:
      case SMTLIBv2Parser::PK_Language:
      case SMTLIBv2Parser::PK_LeftAssoc:
      case SMTLIBv2Parser::PK_License:
      case SMTLIBv2Parser::PK_Named:
      case SMTLIBv2Parser::PK_Name:
      case SMTLIBv2Parser::PK_Notes:
      case SMTLIBv2Parser::PK_Pattern:
      case SMTLIBv2Parser::PK_PrintSuccess:
      case SMTLIBv2Parser::PK_ProduceAssertions:
      case SMTLIBv2Parser::PK_ProduceAssignments:
      case SMTLIBv2Parser::PK_ProduceModels:
      case SMTLIBv2Parser::PK_ProduceProofs:
      case SMTLIBv2Parser::PK_ProduceUnsatAssumptions:
      case SMTLIBv2Parser::PK_ProduceUnsatCores:
      case SMTLIBv2Parser::PK_RandomSeed:
      case SMTLIBv2Parser::PK_ReasonUnknown:
      case SMTLIBv2Parser::PK_RegularOutputChannel:
      case SMTLIBv2Parser::PK_ReproducibleResourceLimit:
      case SMTLIBv2Parser::PK_RightAssoc:
      case SMTLIBv2Parser::PK_SmtLibVersion:
      case SMTLIBv2Parser::PK_Sorts:
      case SMTLIBv2Parser::PK_SortsDescription:
      case SMTLIBv2Parser::PK_Source:
      case SMTLIBv2Parser::PK_Status:
      case SMTLIBv2Parser::PK_Theories:
      case SMTLIBv2Parser::PK_Values:
      case SMTLIBv2Parser::PK_Verbosity:
      case SMTLIBv2Parser::PK_Version: {
        enterOuterAlt(_localctx, 3);
        setState(238);
        keyword();
        break;
      }

      case SMTLIBv2Parser::ParOpen: {
        enterOuterAlt(_localctx, 4);
        setState(239);
        match(SMTLIBv2Parser::ParOpen);
        setState(243);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8388580) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & 140737488355327) != 0)) {
          setState(240);
          s_expr();
          setState(245);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(246);
        match(SMTLIBv2Parser::ParClose);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexContext ------------------------------------------------------------------

SMTLIBv2Parser::IndexContext::IndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::NumeralContext* SMTLIBv2Parser::IndexContext::numeral() {
  return getRuleContext<SMTLIBv2Parser::NumeralContext>(0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::IndexContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}


size_t SMTLIBv2Parser::IndexContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleIndex;
}

void SMTLIBv2Parser::IndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex(this);
}

void SMTLIBv2Parser::IndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex(this);
}


std::any SMTLIBv2Parser::IndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitIndex(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::IndexContext* SMTLIBv2Parser::index() {
  IndexContext *_localctx = _tracker.createInstance<IndexContext>(_ctx, getState());
  enterRule(_localctx, 32, SMTLIBv2Parser::RuleIndex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(251);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::Numeral: {
        enterOuterAlt(_localctx, 1);
        setState(249);
        numeral();
        break;
      }

      case SMTLIBv2Parser::QuotedSymbol:
      case SMTLIBv2Parser::PS_Not:
      case SMTLIBv2Parser::PS_Bool:
      case SMTLIBv2Parser::PS_ContinuedExecution:
      case SMTLIBv2Parser::PS_Error:
      case SMTLIBv2Parser::PS_False:
      case SMTLIBv2Parser::PS_ImmediateExit:
      case SMTLIBv2Parser::PS_Incomplete:
      case SMTLIBv2Parser::PS_Logic:
      case SMTLIBv2Parser::PS_Memout:
      case SMTLIBv2Parser::PS_Sat:
      case SMTLIBv2Parser::PS_Success:
      case SMTLIBv2Parser::PS_Theory:
      case SMTLIBv2Parser::PS_True:
      case SMTLIBv2Parser::PS_Unknown:
      case SMTLIBv2Parser::PS_Unsupported:
      case SMTLIBv2Parser::PS_Unsat:
      case SMTLIBv2Parser::UndefinedSymbol: {
        enterOuterAlt(_localctx, 2);
        setState(250);
        symbol();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

SMTLIBv2Parser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::IdentifierContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::IdentifierContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::IdentifierContext::GRW_Underscore() {
  return getToken(SMTLIBv2Parser::GRW_Underscore, 0);
}

tree::TerminalNode* SMTLIBv2Parser::IdentifierContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::IndexContext *> SMTLIBv2Parser::IdentifierContext::index() {
  return getRuleContexts<SMTLIBv2Parser::IndexContext>();
}

SMTLIBv2Parser::IndexContext* SMTLIBv2Parser::IdentifierContext::index(size_t i) {
  return getRuleContext<SMTLIBv2Parser::IndexContext>(i);
}


size_t SMTLIBv2Parser::IdentifierContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleIdentifier;
}

void SMTLIBv2Parser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void SMTLIBv2Parser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}


std::any SMTLIBv2Parser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::IdentifierContext* SMTLIBv2Parser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 34, SMTLIBv2Parser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(264);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::QuotedSymbol:
      case SMTLIBv2Parser::PS_Not:
      case SMTLIBv2Parser::PS_Bool:
      case SMTLIBv2Parser::PS_ContinuedExecution:
      case SMTLIBv2Parser::PS_Error:
      case SMTLIBv2Parser::PS_False:
      case SMTLIBv2Parser::PS_ImmediateExit:
      case SMTLIBv2Parser::PS_Incomplete:
      case SMTLIBv2Parser::PS_Logic:
      case SMTLIBv2Parser::PS_Memout:
      case SMTLIBv2Parser::PS_Sat:
      case SMTLIBv2Parser::PS_Success:
      case SMTLIBv2Parser::PS_Theory:
      case SMTLIBv2Parser::PS_True:
      case SMTLIBv2Parser::PS_Unknown:
      case SMTLIBv2Parser::PS_Unsupported:
      case SMTLIBv2Parser::PS_Unsat:
      case SMTLIBv2Parser::UndefinedSymbol: {
        enterOuterAlt(_localctx, 1);
        setState(253);
        symbol();
        break;
      }

      case SMTLIBv2Parser::ParOpen: {
        enterOuterAlt(_localctx, 2);
        setState(254);
        match(SMTLIBv2Parser::ParOpen);
        setState(255);
        match(SMTLIBv2Parser::GRW_Underscore);
        setState(256);
        symbol();
        setState(258); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(257);
          index();
          setState(260); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8388544) != 0) || _la == SMTLIBv2Parser::Numeral

        || _la == SMTLIBv2Parser::UndefinedSymbol);
        setState(262);
        match(SMTLIBv2Parser::ParClose);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attribute_valueContext ------------------------------------------------------------------

SMTLIBv2Parser::Attribute_valueContext::Attribute_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::Spec_constantContext* SMTLIBv2Parser::Attribute_valueContext::spec_constant() {
  return getRuleContext<SMTLIBv2Parser::Spec_constantContext>(0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Attribute_valueContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Attribute_valueContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Attribute_valueContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::S_exprContext *> SMTLIBv2Parser::Attribute_valueContext::s_expr() {
  return getRuleContexts<SMTLIBv2Parser::S_exprContext>();
}

SMTLIBv2Parser::S_exprContext* SMTLIBv2Parser::Attribute_valueContext::s_expr(size_t i) {
  return getRuleContext<SMTLIBv2Parser::S_exprContext>(i);
}


size_t SMTLIBv2Parser::Attribute_valueContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleAttribute_value;
}

void SMTLIBv2Parser::Attribute_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute_value(this);
}

void SMTLIBv2Parser::Attribute_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute_value(this);
}


std::any SMTLIBv2Parser::Attribute_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitAttribute_value(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Attribute_valueContext* SMTLIBv2Parser::attribute_value() {
  Attribute_valueContext *_localctx = _tracker.createInstance<Attribute_valueContext>(_ctx, getState());
  enterRule(_localctx, 36, SMTLIBv2Parser::RuleAttribute_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(276);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::String:
      case SMTLIBv2Parser::Numeral:
      case SMTLIBv2Parser::Binary:
      case SMTLIBv2Parser::HexDecimal:
      case SMTLIBv2Parser::Decimal: {
        enterOuterAlt(_localctx, 1);
        setState(266);
        spec_constant();
        break;
      }

      case SMTLIBv2Parser::QuotedSymbol:
      case SMTLIBv2Parser::PS_Not:
      case SMTLIBv2Parser::PS_Bool:
      case SMTLIBv2Parser::PS_ContinuedExecution:
      case SMTLIBv2Parser::PS_Error:
      case SMTLIBv2Parser::PS_False:
      case SMTLIBv2Parser::PS_ImmediateExit:
      case SMTLIBv2Parser::PS_Incomplete:
      case SMTLIBv2Parser::PS_Logic:
      case SMTLIBv2Parser::PS_Memout:
      case SMTLIBv2Parser::PS_Sat:
      case SMTLIBv2Parser::PS_Success:
      case SMTLIBv2Parser::PS_Theory:
      case SMTLIBv2Parser::PS_True:
      case SMTLIBv2Parser::PS_Unknown:
      case SMTLIBv2Parser::PS_Unsupported:
      case SMTLIBv2Parser::PS_Unsat:
      case SMTLIBv2Parser::UndefinedSymbol: {
        enterOuterAlt(_localctx, 2);
        setState(267);
        symbol();
        break;
      }

      case SMTLIBv2Parser::ParOpen: {
        enterOuterAlt(_localctx, 3);
        setState(268);
        match(SMTLIBv2Parser::ParOpen);
        setState(272);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8388580) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & 140737488355327) != 0)) {
          setState(269);
          s_expr();
          setState(274);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(275);
        match(SMTLIBv2Parser::ParClose);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeContext ------------------------------------------------------------------

SMTLIBv2Parser::AttributeContext::AttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::KeywordContext* SMTLIBv2Parser::AttributeContext::keyword() {
  return getRuleContext<SMTLIBv2Parser::KeywordContext>(0);
}

SMTLIBv2Parser::Attribute_valueContext* SMTLIBv2Parser::AttributeContext::attribute_value() {
  return getRuleContext<SMTLIBv2Parser::Attribute_valueContext>(0);
}


size_t SMTLIBv2Parser::AttributeContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleAttribute;
}

void SMTLIBv2Parser::AttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute(this);
}

void SMTLIBv2Parser::AttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute(this);
}


std::any SMTLIBv2Parser::AttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitAttribute(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::attribute() {
  AttributeContext *_localctx = _tracker.createInstance<AttributeContext>(_ctx, getState());
  enterRule(_localctx, 38, SMTLIBv2Parser::RuleAttribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(282);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(278);
      keyword();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(279);
      keyword();
      setState(280);
      attribute_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortContext ------------------------------------------------------------------

SMTLIBv2Parser::SortContext::SortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::IdentifierContext* SMTLIBv2Parser::SortContext::identifier() {
  return getRuleContext<SMTLIBv2Parser::IdentifierContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::SortContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::SortContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::SortContext *> SMTLIBv2Parser::SortContext::sort() {
  return getRuleContexts<SMTLIBv2Parser::SortContext>();
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::SortContext::sort(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SortContext>(i);
}


size_t SMTLIBv2Parser::SortContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSort;
}

void SMTLIBv2Parser::SortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSort(this);
}

void SMTLIBv2Parser::SortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSort(this);
}


std::any SMTLIBv2Parser::SortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSort(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::sort() {
  SortContext *_localctx = _tracker.createInstance<SortContext>(_ctx, getState());
  enterRule(_localctx, 40, SMTLIBv2Parser::RuleSort);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(294);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(284);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(285);
      match(SMTLIBv2Parser::ParOpen);
      setState(286);
      identifier();
      setState(288); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(287);
        sort();
        setState(290); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388548) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol);
      setState(292);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qual_identifierContext ------------------------------------------------------------------

SMTLIBv2Parser::Qual_identifierContext::Qual_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::IdentifierContext* SMTLIBv2Parser::Qual_identifierContext::identifier() {
  return getRuleContext<SMTLIBv2Parser::IdentifierContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Qual_identifierContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Qual_identifierContext::GRW_As() {
  return getToken(SMTLIBv2Parser::GRW_As, 0);
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::Qual_identifierContext::sort() {
  return getRuleContext<SMTLIBv2Parser::SortContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Qual_identifierContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::Qual_identifierContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleQual_identifier;
}

void SMTLIBv2Parser::Qual_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQual_identifier(this);
}

void SMTLIBv2Parser::Qual_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQual_identifier(this);
}


std::any SMTLIBv2Parser::Qual_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitQual_identifier(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Qual_identifierContext* SMTLIBv2Parser::qual_identifier() {
  Qual_identifierContext *_localctx = _tracker.createInstance<Qual_identifierContext>(_ctx, getState());
  enterRule(_localctx, 42, SMTLIBv2Parser::RuleQual_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(303);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(296);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(297);
      match(SMTLIBv2Parser::ParOpen);
      setState(298);
      match(SMTLIBv2Parser::GRW_As);
      setState(299);
      identifier();
      setState(300);
      sort();
      setState(301);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_bindingContext ------------------------------------------------------------------

SMTLIBv2Parser::Var_bindingContext::Var_bindingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Var_bindingContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Var_bindingContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::Var_bindingContext::term() {
  return getRuleContext<SMTLIBv2Parser::TermContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Var_bindingContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::Var_bindingContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleVar_binding;
}

void SMTLIBv2Parser::Var_bindingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_binding(this);
}

void SMTLIBv2Parser::Var_bindingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_binding(this);
}


std::any SMTLIBv2Parser::Var_bindingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitVar_binding(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Var_bindingContext* SMTLIBv2Parser::var_binding() {
  Var_bindingContext *_localctx = _tracker.createInstance<Var_bindingContext>(_ctx, getState());
  enterRule(_localctx, 44, SMTLIBv2Parser::RuleVar_binding);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(305);
    match(SMTLIBv2Parser::ParOpen);
    setState(306);
    symbol();
    setState(307);
    term();
    setState(308);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sorted_varContext ------------------------------------------------------------------

SMTLIBv2Parser::Sorted_varContext::Sorted_varContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Sorted_varContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Sorted_varContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::Sorted_varContext::sort() {
  return getRuleContext<SMTLIBv2Parser::SortContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Sorted_varContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::Sorted_varContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSorted_var;
}

void SMTLIBv2Parser::Sorted_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSorted_var(this);
}

void SMTLIBv2Parser::Sorted_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSorted_var(this);
}


std::any SMTLIBv2Parser::Sorted_varContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSorted_var(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Sorted_varContext* SMTLIBv2Parser::sorted_var() {
  Sorted_varContext *_localctx = _tracker.createInstance<Sorted_varContext>(_ctx, getState());
  enterRule(_localctx, 46, SMTLIBv2Parser::RuleSorted_var);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(310);
    match(SMTLIBv2Parser::ParOpen);
    setState(311);
    symbol();
    setState(312);
    sort();
    setState(313);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternContext ------------------------------------------------------------------

SMTLIBv2Parser::PatternContext::PatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SMTLIBv2Parser::SymbolContext *> SMTLIBv2Parser::PatternContext::symbol() {
  return getRuleContexts<SMTLIBv2Parser::SymbolContext>();
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::PatternContext::symbol(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::PatternContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::PatternContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::PatternContext::getRuleIndex() const {
  return SMTLIBv2Parser::RulePattern;
}

void SMTLIBv2Parser::PatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern(this);
}

void SMTLIBv2Parser::PatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern(this);
}


std::any SMTLIBv2Parser::PatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitPattern(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::PatternContext* SMTLIBv2Parser::pattern() {
  PatternContext *_localctx = _tracker.createInstance<PatternContext>(_ctx, getState());
  enterRule(_localctx, 48, SMTLIBv2Parser::RulePattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(325);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::QuotedSymbol:
      case SMTLIBv2Parser::PS_Not:
      case SMTLIBv2Parser::PS_Bool:
      case SMTLIBv2Parser::PS_ContinuedExecution:
      case SMTLIBv2Parser::PS_Error:
      case SMTLIBv2Parser::PS_False:
      case SMTLIBv2Parser::PS_ImmediateExit:
      case SMTLIBv2Parser::PS_Incomplete:
      case SMTLIBv2Parser::PS_Logic:
      case SMTLIBv2Parser::PS_Memout:
      case SMTLIBv2Parser::PS_Sat:
      case SMTLIBv2Parser::PS_Success:
      case SMTLIBv2Parser::PS_Theory:
      case SMTLIBv2Parser::PS_True:
      case SMTLIBv2Parser::PS_Unknown:
      case SMTLIBv2Parser::PS_Unsupported:
      case SMTLIBv2Parser::PS_Unsat:
      case SMTLIBv2Parser::UndefinedSymbol: {
        enterOuterAlt(_localctx, 1);
        setState(315);
        symbol();
        break;
      }

      case SMTLIBv2Parser::ParOpen: {
        enterOuterAlt(_localctx, 2);
        setState(316);
        match(SMTLIBv2Parser::ParOpen);
        setState(317);
        symbol();
        setState(319); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(318);
          symbol();
          setState(321); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8388544) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol);
        setState(323);
        match(SMTLIBv2Parser::ParClose);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Match_caseContext ------------------------------------------------------------------

SMTLIBv2Parser::Match_caseContext::Match_caseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Match_caseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::PatternContext* SMTLIBv2Parser::Match_caseContext::pattern() {
  return getRuleContext<SMTLIBv2Parser::PatternContext>(0);
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::Match_caseContext::term() {
  return getRuleContext<SMTLIBv2Parser::TermContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Match_caseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::Match_caseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleMatch_case;
}

void SMTLIBv2Parser::Match_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatch_case(this);
}

void SMTLIBv2Parser::Match_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatch_case(this);
}


std::any SMTLIBv2Parser::Match_caseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitMatch_case(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Match_caseContext* SMTLIBv2Parser::match_case() {
  Match_caseContext *_localctx = _tracker.createInstance<Match_caseContext>(_ctx, getState());
  enterRule(_localctx, 50, SMTLIBv2Parser::RuleMatch_case);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(327);
    match(SMTLIBv2Parser::ParOpen);
    setState(328);
    pattern();
    setState(329);
    term();
    setState(330);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TermContext ------------------------------------------------------------------

SMTLIBv2Parser::TermContext::TermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::Spec_constantContext* SMTLIBv2Parser::TermContext::spec_constant() {
  return getRuleContext<SMTLIBv2Parser::Spec_constantContext>(0);
}

SMTLIBv2Parser::Qual_identifierContext* SMTLIBv2Parser::TermContext::qual_identifier() {
  return getRuleContext<SMTLIBv2Parser::Qual_identifierContext>(0);
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::TermContext::ParOpen() {
  return getTokens(SMTLIBv2Parser::ParOpen);
}

tree::TerminalNode* SMTLIBv2Parser::TermContext::ParOpen(size_t i) {
  return getToken(SMTLIBv2Parser::ParOpen, i);
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::TermContext::ParClose() {
  return getTokens(SMTLIBv2Parser::ParClose);
}

tree::TerminalNode* SMTLIBv2Parser::TermContext::ParClose(size_t i) {
  return getToken(SMTLIBv2Parser::ParClose, i);
}

std::vector<SMTLIBv2Parser::TermContext *> SMTLIBv2Parser::TermContext::term() {
  return getRuleContexts<SMTLIBv2Parser::TermContext>();
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::TermContext::term(size_t i) {
  return getRuleContext<SMTLIBv2Parser::TermContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::TermContext::GRW_Let() {
  return getToken(SMTLIBv2Parser::GRW_Let, 0);
}

std::vector<SMTLIBv2Parser::Var_bindingContext *> SMTLIBv2Parser::TermContext::var_binding() {
  return getRuleContexts<SMTLIBv2Parser::Var_bindingContext>();
}

SMTLIBv2Parser::Var_bindingContext* SMTLIBv2Parser::TermContext::var_binding(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Var_bindingContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::TermContext::GRW_Forall() {
  return getToken(SMTLIBv2Parser::GRW_Forall, 0);
}

std::vector<SMTLIBv2Parser::Sorted_varContext *> SMTLIBv2Parser::TermContext::sorted_var() {
  return getRuleContexts<SMTLIBv2Parser::Sorted_varContext>();
}

SMTLIBv2Parser::Sorted_varContext* SMTLIBv2Parser::TermContext::sorted_var(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Sorted_varContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::TermContext::GRW_Exists() {
  return getToken(SMTLIBv2Parser::GRW_Exists, 0);
}

tree::TerminalNode* SMTLIBv2Parser::TermContext::GRW_Match() {
  return getToken(SMTLIBv2Parser::GRW_Match, 0);
}

std::vector<SMTLIBv2Parser::Match_caseContext *> SMTLIBv2Parser::TermContext::match_case() {
  return getRuleContexts<SMTLIBv2Parser::Match_caseContext>();
}

SMTLIBv2Parser::Match_caseContext* SMTLIBv2Parser::TermContext::match_case(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Match_caseContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::TermContext::GRW_Exclamation() {
  return getToken(SMTLIBv2Parser::GRW_Exclamation, 0);
}

std::vector<SMTLIBv2Parser::AttributeContext *> SMTLIBv2Parser::TermContext::attribute() {
  return getRuleContexts<SMTLIBv2Parser::AttributeContext>();
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::TermContext::attribute(size_t i) {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(i);
}


size_t SMTLIBv2Parser::TermContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleTerm;
}

void SMTLIBv2Parser::TermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTerm(this);
}

void SMTLIBv2Parser::TermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTerm(this);
}


std::any SMTLIBv2Parser::TermContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitTerm(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::term() {
  TermContext *_localctx = _tracker.createInstance<TermContext>(_ctx, getState());
  enterRule(_localctx, 52, SMTLIBv2Parser::RuleTerm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(401);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(332);
      spec_constant();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(333);
      qual_identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(334);
      match(SMTLIBv2Parser::ParOpen);
      setState(335);
      qual_identifier();
      setState(337); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(336);
        term();
        setState(339); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388580) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 70368744177679) != 0));
      setState(341);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(343);
      match(SMTLIBv2Parser::ParOpen);
      setState(344);
      match(SMTLIBv2Parser::GRW_Let);
      setState(345);
      match(SMTLIBv2Parser::ParOpen);
      setState(347); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(346);
        var_binding();
        setState(349); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(351);
      match(SMTLIBv2Parser::ParClose);
      setState(352);
      term();
      setState(353);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(355);
      match(SMTLIBv2Parser::ParOpen);
      setState(356);
      match(SMTLIBv2Parser::GRW_Forall);
      setState(357);
      match(SMTLIBv2Parser::ParOpen);
      setState(359); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(358);
        sorted_var();
        setState(361); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(363);
      match(SMTLIBv2Parser::ParClose);
      setState(364);
      term();
      setState(365);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(367);
      match(SMTLIBv2Parser::ParOpen);
      setState(368);
      match(SMTLIBv2Parser::GRW_Exists);
      setState(369);
      match(SMTLIBv2Parser::ParOpen);
      setState(371); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(370);
        sorted_var();
        setState(373); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(375);
      match(SMTLIBv2Parser::ParClose);
      setState(376);
      term();
      setState(377);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(379);
      match(SMTLIBv2Parser::ParOpen);
      setState(380);
      match(SMTLIBv2Parser::GRW_Match);
      setState(381);
      term();
      setState(382);
      match(SMTLIBv2Parser::ParOpen);
      setState(384); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(383);
        match_case();
        setState(386); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(388);
      match(SMTLIBv2Parser::ParClose);
      setState(389);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(391);
      match(SMTLIBv2Parser::ParOpen);
      setState(392);
      match(SMTLIBv2Parser::GRW_Exclamation);
      setState(393);
      term();
      setState(395); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(394);
        attribute();
        setState(397); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & 4398046511103) != 0));
      setState(399);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sort_symbol_declContext ------------------------------------------------------------------

SMTLIBv2Parser::Sort_symbol_declContext::Sort_symbol_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Sort_symbol_declContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::IdentifierContext* SMTLIBv2Parser::Sort_symbol_declContext::identifier() {
  return getRuleContext<SMTLIBv2Parser::IdentifierContext>(0);
}

SMTLIBv2Parser::NumeralContext* SMTLIBv2Parser::Sort_symbol_declContext::numeral() {
  return getRuleContext<SMTLIBv2Parser::NumeralContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Sort_symbol_declContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::AttributeContext *> SMTLIBv2Parser::Sort_symbol_declContext::attribute() {
  return getRuleContexts<SMTLIBv2Parser::AttributeContext>();
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::Sort_symbol_declContext::attribute(size_t i) {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(i);
}


size_t SMTLIBv2Parser::Sort_symbol_declContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSort_symbol_decl;
}

void SMTLIBv2Parser::Sort_symbol_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSort_symbol_decl(this);
}

void SMTLIBv2Parser::Sort_symbol_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSort_symbol_decl(this);
}


std::any SMTLIBv2Parser::Sort_symbol_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSort_symbol_decl(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Sort_symbol_declContext* SMTLIBv2Parser::sort_symbol_decl() {
  Sort_symbol_declContext *_localctx = _tracker.createInstance<Sort_symbol_declContext>(_ctx, getState());
  enterRule(_localctx, 54, SMTLIBv2Parser::RuleSort_symbol_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(403);
    match(SMTLIBv2Parser::ParOpen);
    setState(404);
    identifier();
    setState(405);
    numeral();
    setState(409);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 4398046511103) != 0)) {
      setState(406);
      attribute();
      setState(411);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(412);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meta_spec_constantContext ------------------------------------------------------------------

SMTLIBv2Parser::Meta_spec_constantContext::Meta_spec_constantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Meta_spec_constantContext::GRW_Numeral() {
  return getToken(SMTLIBv2Parser::GRW_Numeral, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Meta_spec_constantContext::GRW_Decimal() {
  return getToken(SMTLIBv2Parser::GRW_Decimal, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Meta_spec_constantContext::GRW_String() {
  return getToken(SMTLIBv2Parser::GRW_String, 0);
}


size_t SMTLIBv2Parser::Meta_spec_constantContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleMeta_spec_constant;
}

void SMTLIBv2Parser::Meta_spec_constantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeta_spec_constant(this);
}

void SMTLIBv2Parser::Meta_spec_constantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeta_spec_constant(this);
}


std::any SMTLIBv2Parser::Meta_spec_constantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitMeta_spec_constant(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Meta_spec_constantContext* SMTLIBv2Parser::meta_spec_constant() {
  Meta_spec_constantContext *_localctx = _tracker.createInstance<Meta_spec_constantContext>(_ctx, getState());
  enterRule(_localctx, 56, SMTLIBv2Parser::RuleMeta_spec_constant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(414);
    _la = _input->LA(1);
    if (!(((((_la - 57) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 57)) & 321) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fun_symbol_declContext ------------------------------------------------------------------

SMTLIBv2Parser::Fun_symbol_declContext::Fun_symbol_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Fun_symbol_declContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::Spec_constantContext* SMTLIBv2Parser::Fun_symbol_declContext::spec_constant() {
  return getRuleContext<SMTLIBv2Parser::Spec_constantContext>(0);
}

std::vector<SMTLIBv2Parser::SortContext *> SMTLIBv2Parser::Fun_symbol_declContext::sort() {
  return getRuleContexts<SMTLIBv2Parser::SortContext>();
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::Fun_symbol_declContext::sort(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SortContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::Fun_symbol_declContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::AttributeContext *> SMTLIBv2Parser::Fun_symbol_declContext::attribute() {
  return getRuleContexts<SMTLIBv2Parser::AttributeContext>();
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::Fun_symbol_declContext::attribute(size_t i) {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(i);
}

SMTLIBv2Parser::Meta_spec_constantContext* SMTLIBv2Parser::Fun_symbol_declContext::meta_spec_constant() {
  return getRuleContext<SMTLIBv2Parser::Meta_spec_constantContext>(0);
}

SMTLIBv2Parser::IdentifierContext* SMTLIBv2Parser::Fun_symbol_declContext::identifier() {
  return getRuleContext<SMTLIBv2Parser::IdentifierContext>(0);
}


size_t SMTLIBv2Parser::Fun_symbol_declContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleFun_symbol_decl;
}

void SMTLIBv2Parser::Fun_symbol_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFun_symbol_decl(this);
}

void SMTLIBv2Parser::Fun_symbol_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFun_symbol_decl(this);
}


std::any SMTLIBv2Parser::Fun_symbol_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitFun_symbol_decl(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Fun_symbol_declContext* SMTLIBv2Parser::fun_symbol_decl() {
  Fun_symbol_declContext *_localctx = _tracker.createInstance<Fun_symbol_declContext>(_ctx, getState());
  enterRule(_localctx, 58, SMTLIBv2Parser::RuleFun_symbol_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(453);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(416);
      match(SMTLIBv2Parser::ParOpen);
      setState(417);
      spec_constant();
      setState(418);
      sort();
      setState(422);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & 4398046511103) != 0)) {
        setState(419);
        attribute();
        setState(424);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(425);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(427);
      match(SMTLIBv2Parser::ParOpen);
      setState(428);
      meta_spec_constant();
      setState(429);
      sort();
      setState(433);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & 4398046511103) != 0)) {
        setState(430);
        attribute();
        setState(435);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(436);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(438);
      match(SMTLIBv2Parser::ParOpen);
      setState(439);
      identifier();
      setState(441); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(440);
        sort();
        setState(443); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388548) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol);
      setState(448);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & 4398046511103) != 0)) {
        setState(445);
        attribute();
        setState(450);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(451);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Par_fun_symbol_declContext ------------------------------------------------------------------

SMTLIBv2Parser::Par_fun_symbol_declContext::Par_fun_symbol_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::Fun_symbol_declContext* SMTLIBv2Parser::Par_fun_symbol_declContext::fun_symbol_decl() {
  return getRuleContext<SMTLIBv2Parser::Fun_symbol_declContext>(0);
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::Par_fun_symbol_declContext::ParOpen() {
  return getTokens(SMTLIBv2Parser::ParOpen);
}

tree::TerminalNode* SMTLIBv2Parser::Par_fun_symbol_declContext::ParOpen(size_t i) {
  return getToken(SMTLIBv2Parser::ParOpen, i);
}

tree::TerminalNode* SMTLIBv2Parser::Par_fun_symbol_declContext::GRW_Par() {
  return getToken(SMTLIBv2Parser::GRW_Par, 0);
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::Par_fun_symbol_declContext::ParClose() {
  return getTokens(SMTLIBv2Parser::ParClose);
}

tree::TerminalNode* SMTLIBv2Parser::Par_fun_symbol_declContext::ParClose(size_t i) {
  return getToken(SMTLIBv2Parser::ParClose, i);
}

SMTLIBv2Parser::IdentifierContext* SMTLIBv2Parser::Par_fun_symbol_declContext::identifier() {
  return getRuleContext<SMTLIBv2Parser::IdentifierContext>(0);
}

std::vector<SMTLIBv2Parser::SymbolContext *> SMTLIBv2Parser::Par_fun_symbol_declContext::symbol() {
  return getRuleContexts<SMTLIBv2Parser::SymbolContext>();
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Par_fun_symbol_declContext::symbol(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(i);
}

std::vector<SMTLIBv2Parser::SortContext *> SMTLIBv2Parser::Par_fun_symbol_declContext::sort() {
  return getRuleContexts<SMTLIBv2Parser::SortContext>();
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::Par_fun_symbol_declContext::sort(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SortContext>(i);
}

std::vector<SMTLIBv2Parser::AttributeContext *> SMTLIBv2Parser::Par_fun_symbol_declContext::attribute() {
  return getRuleContexts<SMTLIBv2Parser::AttributeContext>();
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::Par_fun_symbol_declContext::attribute(size_t i) {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(i);
}


size_t SMTLIBv2Parser::Par_fun_symbol_declContext::getRuleIndex() const {
  return SMTLIBv2Parser::RulePar_fun_symbol_decl;
}

void SMTLIBv2Parser::Par_fun_symbol_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPar_fun_symbol_decl(this);
}

void SMTLIBv2Parser::Par_fun_symbol_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPar_fun_symbol_decl(this);
}


std::any SMTLIBv2Parser::Par_fun_symbol_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitPar_fun_symbol_decl(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Par_fun_symbol_declContext* SMTLIBv2Parser::par_fun_symbol_decl() {
  Par_fun_symbol_declContext *_localctx = _tracker.createInstance<Par_fun_symbol_declContext>(_ctx, getState());
  enterRule(_localctx, 60, SMTLIBv2Parser::RulePar_fun_symbol_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(481);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(455);
      fun_symbol_decl();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(456);
      match(SMTLIBv2Parser::ParOpen);
      setState(457);
      match(SMTLIBv2Parser::GRW_Par);
      setState(458);
      match(SMTLIBv2Parser::ParOpen);
      setState(460); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(459);
        symbol();
        setState(462); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388544) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol);
      setState(464);
      match(SMTLIBv2Parser::ParClose);
      setState(465);
      match(SMTLIBv2Parser::ParOpen);
      setState(466);
      identifier();
      setState(468); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(467);
        sort();
        setState(470); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388548) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol);
      setState(475);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & 4398046511103) != 0)) {
        setState(472);
        attribute();
        setState(477);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(478);
      match(SMTLIBv2Parser::ParClose);
      setState(479);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Theory_attributeContext ------------------------------------------------------------------

SMTLIBv2Parser::Theory_attributeContext::Theory_attributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::PK_Sorts() {
  return getToken(SMTLIBv2Parser::PK_Sorts, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::Sort_symbol_declContext *> SMTLIBv2Parser::Theory_attributeContext::sort_symbol_decl() {
  return getRuleContexts<SMTLIBv2Parser::Sort_symbol_declContext>();
}

SMTLIBv2Parser::Sort_symbol_declContext* SMTLIBv2Parser::Theory_attributeContext::sort_symbol_decl(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Sort_symbol_declContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::PK_Funs() {
  return getToken(SMTLIBv2Parser::PK_Funs, 0);
}

std::vector<SMTLIBv2Parser::Par_fun_symbol_declContext *> SMTLIBv2Parser::Theory_attributeContext::par_fun_symbol_decl() {
  return getRuleContexts<SMTLIBv2Parser::Par_fun_symbol_declContext>();
}

SMTLIBv2Parser::Par_fun_symbol_declContext* SMTLIBv2Parser::Theory_attributeContext::par_fun_symbol_decl(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Par_fun_symbol_declContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::PK_SortsDescription() {
  return getToken(SMTLIBv2Parser::PK_SortsDescription, 0);
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::Theory_attributeContext::string() {
  return getRuleContext<SMTLIBv2Parser::StringContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::PK_FunsDescription() {
  return getToken(SMTLIBv2Parser::PK_FunsDescription, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::PK_Definition() {
  return getToken(SMTLIBv2Parser::PK_Definition, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::PK_Values() {
  return getToken(SMTLIBv2Parser::PK_Values, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_attributeContext::PK_Notes() {
  return getToken(SMTLIBv2Parser::PK_Notes, 0);
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::Theory_attributeContext::attribute() {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(0);
}


size_t SMTLIBv2Parser::Theory_attributeContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleTheory_attribute;
}

void SMTLIBv2Parser::Theory_attributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTheory_attribute(this);
}

void SMTLIBv2Parser::Theory_attributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTheory_attribute(this);
}


std::any SMTLIBv2Parser::Theory_attributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitTheory_attribute(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Theory_attributeContext* SMTLIBv2Parser::theory_attribute() {
  Theory_attributeContext *_localctx = _tracker.createInstance<Theory_attributeContext>(_ctx, getState());
  enterRule(_localctx, 62, SMTLIBv2Parser::RuleTheory_attribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(512);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(483);
      match(SMTLIBv2Parser::PK_Sorts);
      setState(484);
      match(SMTLIBv2Parser::ParOpen);
      setState(486); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(485);
        sort_symbol_decl();
        setState(488); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(490);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(492);
      match(SMTLIBv2Parser::PK_Funs);
      setState(493);
      match(SMTLIBv2Parser::ParOpen);
      setState(495); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(494);
        par_fun_symbol_decl();
        setState(497); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(499);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(501);
      match(SMTLIBv2Parser::PK_SortsDescription);
      setState(502);
      string();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(503);
      match(SMTLIBv2Parser::PK_FunsDescription);
      setState(504);
      string();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(505);
      match(SMTLIBv2Parser::PK_Definition);
      setState(506);
      string();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(507);
      match(SMTLIBv2Parser::PK_Values);
      setState(508);
      string();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(509);
      match(SMTLIBv2Parser::PK_Notes);
      setState(510);
      string();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(511);
      attribute();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Theory_declContext ------------------------------------------------------------------

SMTLIBv2Parser::Theory_declContext::Theory_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Theory_declContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_declContext::PS_Theory() {
  return getToken(SMTLIBv2Parser::PS_Theory, 0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Theory_declContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Theory_declContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::Theory_attributeContext *> SMTLIBv2Parser::Theory_declContext::theory_attribute() {
  return getRuleContexts<SMTLIBv2Parser::Theory_attributeContext>();
}

SMTLIBv2Parser::Theory_attributeContext* SMTLIBv2Parser::Theory_declContext::theory_attribute(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Theory_attributeContext>(i);
}


size_t SMTLIBv2Parser::Theory_declContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleTheory_decl;
}

void SMTLIBv2Parser::Theory_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTheory_decl(this);
}

void SMTLIBv2Parser::Theory_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTheory_decl(this);
}


std::any SMTLIBv2Parser::Theory_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitTheory_decl(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Theory_declContext* SMTLIBv2Parser::theory_decl() {
  Theory_declContext *_localctx = _tracker.createInstance<Theory_declContext>(_ctx, getState());
  enterRule(_localctx, 64, SMTLIBv2Parser::RuleTheory_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(514);
    match(SMTLIBv2Parser::ParOpen);
    setState(515);
    match(SMTLIBv2Parser::PS_Theory);
    setState(516);
    symbol();
    setState(518); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(517);
      theory_attribute();
      setState(520); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 4398046511103) != 0));
    setState(522);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Logic_attribueContext ------------------------------------------------------------------

SMTLIBv2Parser::Logic_attribueContext::Logic_attribueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Logic_attribueContext::PK_Theories() {
  return getToken(SMTLIBv2Parser::PK_Theories, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Logic_attribueContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Logic_attribueContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::SymbolContext *> SMTLIBv2Parser::Logic_attribueContext::symbol() {
  return getRuleContexts<SMTLIBv2Parser::SymbolContext>();
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Logic_attribueContext::symbol(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::Logic_attribueContext::PK_Language() {
  return getToken(SMTLIBv2Parser::PK_Language, 0);
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::Logic_attribueContext::string() {
  return getRuleContext<SMTLIBv2Parser::StringContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Logic_attribueContext::PK_Extension() {
  return getToken(SMTLIBv2Parser::PK_Extension, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Logic_attribueContext::PK_Values() {
  return getToken(SMTLIBv2Parser::PK_Values, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Logic_attribueContext::PK_Notes() {
  return getToken(SMTLIBv2Parser::PK_Notes, 0);
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::Logic_attribueContext::attribute() {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(0);
}


size_t SMTLIBv2Parser::Logic_attribueContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleLogic_attribue;
}

void SMTLIBv2Parser::Logic_attribueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogic_attribue(this);
}

void SMTLIBv2Parser::Logic_attribueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogic_attribue(this);
}


std::any SMTLIBv2Parser::Logic_attribueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitLogic_attribue(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Logic_attribueContext* SMTLIBv2Parser::logic_attribue() {
  Logic_attribueContext *_localctx = _tracker.createInstance<Logic_attribueContext>(_ctx, getState());
  enterRule(_localctx, 66, SMTLIBv2Parser::RuleLogic_attribue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(542);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(524);
      match(SMTLIBv2Parser::PK_Theories);
      setState(525);
      match(SMTLIBv2Parser::ParOpen);
      setState(527); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(526);
        symbol();
        setState(529); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388544) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol);
      setState(531);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(533);
      match(SMTLIBv2Parser::PK_Language);
      setState(534);
      string();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(535);
      match(SMTLIBv2Parser::PK_Extension);
      setState(536);
      string();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(537);
      match(SMTLIBv2Parser::PK_Values);
      setState(538);
      string();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(539);
      match(SMTLIBv2Parser::PK_Notes);
      setState(540);
      string();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(541);
      attribute();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicContext ------------------------------------------------------------------

SMTLIBv2Parser::LogicContext::LogicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::LogicContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::LogicContext::PS_Logic() {
  return getToken(SMTLIBv2Parser::PS_Logic, 0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::LogicContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::LogicContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::Logic_attribueContext *> SMTLIBv2Parser::LogicContext::logic_attribue() {
  return getRuleContexts<SMTLIBv2Parser::Logic_attribueContext>();
}

SMTLIBv2Parser::Logic_attribueContext* SMTLIBv2Parser::LogicContext::logic_attribue(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Logic_attribueContext>(i);
}


size_t SMTLIBv2Parser::LogicContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleLogic;
}

void SMTLIBv2Parser::LogicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogic(this);
}

void SMTLIBv2Parser::LogicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogic(this);
}


std::any SMTLIBv2Parser::LogicContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitLogic(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::LogicContext* SMTLIBv2Parser::logic() {
  LogicContext *_localctx = _tracker.createInstance<LogicContext>(_ctx, getState());
  enterRule(_localctx, 68, SMTLIBv2Parser::RuleLogic);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(544);
    match(SMTLIBv2Parser::ParOpen);
    setState(545);
    match(SMTLIBv2Parser::PS_Logic);
    setState(546);
    symbol();
    setState(548); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(547);
      logic_attribue();
      setState(550); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 4398046511103) != 0));
    setState(552);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sort_decContext ------------------------------------------------------------------

SMTLIBv2Parser::Sort_decContext::Sort_decContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Sort_decContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Sort_decContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

SMTLIBv2Parser::NumeralContext* SMTLIBv2Parser::Sort_decContext::numeral() {
  return getRuleContext<SMTLIBv2Parser::NumeralContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Sort_decContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::Sort_decContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSort_dec;
}

void SMTLIBv2Parser::Sort_decContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSort_dec(this);
}

void SMTLIBv2Parser::Sort_decContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSort_dec(this);
}


std::any SMTLIBv2Parser::Sort_decContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSort_dec(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Sort_decContext* SMTLIBv2Parser::sort_dec() {
  Sort_decContext *_localctx = _tracker.createInstance<Sort_decContext>(_ctx, getState());
  enterRule(_localctx, 70, SMTLIBv2Parser::RuleSort_dec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(554);
    match(SMTLIBv2Parser::ParOpen);
    setState(555);
    symbol();
    setState(556);
    numeral();
    setState(557);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Selector_decContext ------------------------------------------------------------------

SMTLIBv2Parser::Selector_decContext::Selector_decContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Selector_decContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Selector_decContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::Selector_decContext::sort() {
  return getRuleContext<SMTLIBv2Parser::SortContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Selector_decContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::Selector_decContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSelector_dec;
}

void SMTLIBv2Parser::Selector_decContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelector_dec(this);
}

void SMTLIBv2Parser::Selector_decContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelector_dec(this);
}


std::any SMTLIBv2Parser::Selector_decContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSelector_dec(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Selector_decContext* SMTLIBv2Parser::selector_dec() {
  Selector_decContext *_localctx = _tracker.createInstance<Selector_decContext>(_ctx, getState());
  enterRule(_localctx, 72, SMTLIBv2Parser::RuleSelector_dec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    match(SMTLIBv2Parser::ParOpen);
    setState(560);
    symbol();
    setState(561);
    sort();
    setState(562);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constructor_decContext ------------------------------------------------------------------

SMTLIBv2Parser::Constructor_decContext::Constructor_decContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Constructor_decContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Constructor_decContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Constructor_decContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::Selector_decContext *> SMTLIBv2Parser::Constructor_decContext::selector_dec() {
  return getRuleContexts<SMTLIBv2Parser::Selector_decContext>();
}

SMTLIBv2Parser::Selector_decContext* SMTLIBv2Parser::Constructor_decContext::selector_dec(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Selector_decContext>(i);
}


size_t SMTLIBv2Parser::Constructor_decContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleConstructor_dec;
}

void SMTLIBv2Parser::Constructor_decContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructor_dec(this);
}

void SMTLIBv2Parser::Constructor_decContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructor_dec(this);
}


std::any SMTLIBv2Parser::Constructor_decContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitConstructor_dec(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Constructor_decContext* SMTLIBv2Parser::constructor_dec() {
  Constructor_decContext *_localctx = _tracker.createInstance<Constructor_decContext>(_ctx, getState());
  enterRule(_localctx, 74, SMTLIBv2Parser::RuleConstructor_dec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(564);
    match(SMTLIBv2Parser::ParOpen);
    setState(565);
    symbol();
    setState(569);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SMTLIBv2Parser::ParOpen) {
      setState(566);
      selector_dec();
      setState(571);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(572);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datatype_decContext ------------------------------------------------------------------

SMTLIBv2Parser::Datatype_decContext::Datatype_decContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::Datatype_decContext::ParOpen() {
  return getTokens(SMTLIBv2Parser::ParOpen);
}

tree::TerminalNode* SMTLIBv2Parser::Datatype_decContext::ParOpen(size_t i) {
  return getToken(SMTLIBv2Parser::ParOpen, i);
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::Datatype_decContext::ParClose() {
  return getTokens(SMTLIBv2Parser::ParClose);
}

tree::TerminalNode* SMTLIBv2Parser::Datatype_decContext::ParClose(size_t i) {
  return getToken(SMTLIBv2Parser::ParClose, i);
}

std::vector<SMTLIBv2Parser::Constructor_decContext *> SMTLIBv2Parser::Datatype_decContext::constructor_dec() {
  return getRuleContexts<SMTLIBv2Parser::Constructor_decContext>();
}

SMTLIBv2Parser::Constructor_decContext* SMTLIBv2Parser::Datatype_decContext::constructor_dec(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Constructor_decContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::Datatype_decContext::GRW_Par() {
  return getToken(SMTLIBv2Parser::GRW_Par, 0);
}

std::vector<SMTLIBv2Parser::SymbolContext *> SMTLIBv2Parser::Datatype_decContext::symbol() {
  return getRuleContexts<SMTLIBv2Parser::SymbolContext>();
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Datatype_decContext::symbol(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(i);
}


size_t SMTLIBv2Parser::Datatype_decContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleDatatype_dec;
}

void SMTLIBv2Parser::Datatype_decContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatatype_dec(this);
}

void SMTLIBv2Parser::Datatype_decContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatatype_dec(this);
}


std::any SMTLIBv2Parser::Datatype_decContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitDatatype_dec(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Datatype_decContext* SMTLIBv2Parser::datatype_dec() {
  Datatype_decContext *_localctx = _tracker.createInstance<Datatype_decContext>(_ctx, getState());
  enterRule(_localctx, 76, SMTLIBv2Parser::RuleDatatype_dec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(600);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(574);
      match(SMTLIBv2Parser::ParOpen);
      setState(576); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(575);
        constructor_dec();
        setState(578); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(580);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(582);
      match(SMTLIBv2Parser::ParOpen);
      setState(583);
      match(SMTLIBv2Parser::GRW_Par);
      setState(584);
      match(SMTLIBv2Parser::ParOpen);
      setState(586); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(585);
        symbol();
        setState(588); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388544) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol);
      setState(590);
      match(SMTLIBv2Parser::ParClose);
      setState(591);
      match(SMTLIBv2Parser::ParOpen);
      setState(593); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(592);
        constructor_dec();
        setState(595); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(597);
      match(SMTLIBv2Parser::ParClose);
      setState(598);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_decContext ------------------------------------------------------------------

SMTLIBv2Parser::Function_decContext::Function_decContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::Function_decContext::ParOpen() {
  return getTokens(SMTLIBv2Parser::ParOpen);
}

tree::TerminalNode* SMTLIBv2Parser::Function_decContext::ParOpen(size_t i) {
  return getToken(SMTLIBv2Parser::ParOpen, i);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Function_decContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::Function_decContext::ParClose() {
  return getTokens(SMTLIBv2Parser::ParClose);
}

tree::TerminalNode* SMTLIBv2Parser::Function_decContext::ParClose(size_t i) {
  return getToken(SMTLIBv2Parser::ParClose, i);
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::Function_decContext::sort() {
  return getRuleContext<SMTLIBv2Parser::SortContext>(0);
}

std::vector<SMTLIBv2Parser::Sorted_varContext *> SMTLIBv2Parser::Function_decContext::sorted_var() {
  return getRuleContexts<SMTLIBv2Parser::Sorted_varContext>();
}

SMTLIBv2Parser::Sorted_varContext* SMTLIBv2Parser::Function_decContext::sorted_var(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Sorted_varContext>(i);
}


size_t SMTLIBv2Parser::Function_decContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleFunction_dec;
}

void SMTLIBv2Parser::Function_decContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_dec(this);
}

void SMTLIBv2Parser::Function_decContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_dec(this);
}


std::any SMTLIBv2Parser::Function_decContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitFunction_dec(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Function_decContext* SMTLIBv2Parser::function_dec() {
  Function_decContext *_localctx = _tracker.createInstance<Function_decContext>(_ctx, getState());
  enterRule(_localctx, 78, SMTLIBv2Parser::RuleFunction_dec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(602);
    match(SMTLIBv2Parser::ParOpen);
    setState(603);
    symbol();
    setState(604);
    match(SMTLIBv2Parser::ParOpen);
    setState(608);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SMTLIBv2Parser::ParOpen) {
      setState(605);
      sorted_var();
      setState(610);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(611);
    match(SMTLIBv2Parser::ParClose);
    setState(612);
    sort();
    setState(613);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_defContext ------------------------------------------------------------------

SMTLIBv2Parser::Function_defContext::Function_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Function_defContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Function_defContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Function_defContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::Function_defContext::sort() {
  return getRuleContext<SMTLIBv2Parser::SortContext>(0);
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::Function_defContext::term() {
  return getRuleContext<SMTLIBv2Parser::TermContext>(0);
}

std::vector<SMTLIBv2Parser::Sorted_varContext *> SMTLIBv2Parser::Function_defContext::sorted_var() {
  return getRuleContexts<SMTLIBv2Parser::Sorted_varContext>();
}

SMTLIBv2Parser::Sorted_varContext* SMTLIBv2Parser::Function_defContext::sorted_var(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Sorted_varContext>(i);
}


size_t SMTLIBv2Parser::Function_defContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleFunction_def;
}

void SMTLIBv2Parser::Function_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_def(this);
}

void SMTLIBv2Parser::Function_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_def(this);
}


std::any SMTLIBv2Parser::Function_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitFunction_def(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Function_defContext* SMTLIBv2Parser::function_def() {
  Function_defContext *_localctx = _tracker.createInstance<Function_defContext>(_ctx, getState());
  enterRule(_localctx, 80, SMTLIBv2Parser::RuleFunction_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(615);
    symbol();
    setState(616);
    match(SMTLIBv2Parser::ParOpen);
    setState(620);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SMTLIBv2Parser::ParOpen) {
      setState(617);
      sorted_var();
      setState(622);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(623);
    match(SMTLIBv2Parser::ParClose);
    setState(624);
    sort();
    setState(625);
    term();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prop_literalContext ------------------------------------------------------------------

SMTLIBv2Parser::Prop_literalContext::Prop_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Prop_literalContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Prop_literalContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Prop_literalContext::PS_Not() {
  return getToken(SMTLIBv2Parser::PS_Not, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Prop_literalContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::Prop_literalContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleProp_literal;
}

void SMTLIBv2Parser::Prop_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProp_literal(this);
}

void SMTLIBv2Parser::Prop_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProp_literal(this);
}


std::any SMTLIBv2Parser::Prop_literalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitProp_literal(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Prop_literalContext* SMTLIBv2Parser::prop_literal() {
  Prop_literalContext *_localctx = _tracker.createInstance<Prop_literalContext>(_ctx, getState());
  enterRule(_localctx, 82, SMTLIBv2Parser::RuleProp_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(633);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SMTLIBv2Parser::QuotedSymbol:
      case SMTLIBv2Parser::PS_Not:
      case SMTLIBv2Parser::PS_Bool:
      case SMTLIBv2Parser::PS_ContinuedExecution:
      case SMTLIBv2Parser::PS_Error:
      case SMTLIBv2Parser::PS_False:
      case SMTLIBv2Parser::PS_ImmediateExit:
      case SMTLIBv2Parser::PS_Incomplete:
      case SMTLIBv2Parser::PS_Logic:
      case SMTLIBv2Parser::PS_Memout:
      case SMTLIBv2Parser::PS_Sat:
      case SMTLIBv2Parser::PS_Success:
      case SMTLIBv2Parser::PS_Theory:
      case SMTLIBv2Parser::PS_True:
      case SMTLIBv2Parser::PS_Unknown:
      case SMTLIBv2Parser::PS_Unsupported:
      case SMTLIBv2Parser::PS_Unsat:
      case SMTLIBv2Parser::UndefinedSymbol: {
        enterOuterAlt(_localctx, 1);
        setState(627);
        symbol();
        break;
      }

      case SMTLIBv2Parser::ParOpen: {
        enterOuterAlt(_localctx, 2);
        setState(628);
        match(SMTLIBv2Parser::ParOpen);
        setState(629);
        match(SMTLIBv2Parser::PS_Not);
        setState(630);
        symbol();
        setState(631);
        match(SMTLIBv2Parser::ParClose);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScriptContext ------------------------------------------------------------------

SMTLIBv2Parser::ScriptContext::ScriptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SMTLIBv2Parser::CommandContext *> SMTLIBv2Parser::ScriptContext::command() {
  return getRuleContexts<SMTLIBv2Parser::CommandContext>();
}

SMTLIBv2Parser::CommandContext* SMTLIBv2Parser::ScriptContext::command(size_t i) {
  return getRuleContext<SMTLIBv2Parser::CommandContext>(i);
}


size_t SMTLIBv2Parser::ScriptContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleScript;
}

void SMTLIBv2Parser::ScriptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScript(this);
}

void SMTLIBv2Parser::ScriptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScript(this);
}


std::any SMTLIBv2Parser::ScriptContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitScript(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::ScriptContext* SMTLIBv2Parser::script() {
  ScriptContext *_localctx = _tracker.createInstance<ScriptContext>(_ctx, getState());
  enterRule(_localctx, 84, SMTLIBv2Parser::RuleScript);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(638);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SMTLIBv2Parser::ParOpen) {
      setState(635);
      command();
      setState(640);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_assertContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_assertContext::Cmd_assertContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_assertContext::CMD_Assert() {
  return getToken(SMTLIBv2Parser::CMD_Assert, 0);
}


size_t SMTLIBv2Parser::Cmd_assertContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_assert;
}

void SMTLIBv2Parser::Cmd_assertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_assert(this);
}

void SMTLIBv2Parser::Cmd_assertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_assert(this);
}


std::any SMTLIBv2Parser::Cmd_assertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_assert(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_assertContext* SMTLIBv2Parser::cmd_assert() {
  Cmd_assertContext *_localctx = _tracker.createInstance<Cmd_assertContext>(_ctx, getState());
  enterRule(_localctx, 86, SMTLIBv2Parser::RuleCmd_assert);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(641);
    match(SMTLIBv2Parser::CMD_Assert);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_checkSatContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_checkSatContext::Cmd_checkSatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_checkSatContext::CMD_CheckSat() {
  return getToken(SMTLIBv2Parser::CMD_CheckSat, 0);
}


size_t SMTLIBv2Parser::Cmd_checkSatContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_checkSat;
}

void SMTLIBv2Parser::Cmd_checkSatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_checkSat(this);
}

void SMTLIBv2Parser::Cmd_checkSatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_checkSat(this);
}


std::any SMTLIBv2Parser::Cmd_checkSatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_checkSat(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_checkSatContext* SMTLIBv2Parser::cmd_checkSat() {
  Cmd_checkSatContext *_localctx = _tracker.createInstance<Cmd_checkSatContext>(_ctx, getState());
  enterRule(_localctx, 88, SMTLIBv2Parser::RuleCmd_checkSat);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    match(SMTLIBv2Parser::CMD_CheckSat);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_checkSatAssumingContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_checkSatAssumingContext::Cmd_checkSatAssumingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_checkSatAssumingContext::CMD_CheckSatAssuming() {
  return getToken(SMTLIBv2Parser::CMD_CheckSatAssuming, 0);
}


size_t SMTLIBv2Parser::Cmd_checkSatAssumingContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_checkSatAssuming;
}

void SMTLIBv2Parser::Cmd_checkSatAssumingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_checkSatAssuming(this);
}

void SMTLIBv2Parser::Cmd_checkSatAssumingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_checkSatAssuming(this);
}


std::any SMTLIBv2Parser::Cmd_checkSatAssumingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_checkSatAssuming(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_checkSatAssumingContext* SMTLIBv2Parser::cmd_checkSatAssuming() {
  Cmd_checkSatAssumingContext *_localctx = _tracker.createInstance<Cmd_checkSatAssumingContext>(_ctx, getState());
  enterRule(_localctx, 90, SMTLIBv2Parser::RuleCmd_checkSatAssuming);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(645);
    match(SMTLIBv2Parser::CMD_CheckSatAssuming);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_declareConstContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_declareConstContext::Cmd_declareConstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_declareConstContext::CMD_DeclareConst() {
  return getToken(SMTLIBv2Parser::CMD_DeclareConst, 0);
}


size_t SMTLIBv2Parser::Cmd_declareConstContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_declareConst;
}

void SMTLIBv2Parser::Cmd_declareConstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_declareConst(this);
}

void SMTLIBv2Parser::Cmd_declareConstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_declareConst(this);
}


std::any SMTLIBv2Parser::Cmd_declareConstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_declareConst(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_declareConstContext* SMTLIBv2Parser::cmd_declareConst() {
  Cmd_declareConstContext *_localctx = _tracker.createInstance<Cmd_declareConstContext>(_ctx, getState());
  enterRule(_localctx, 92, SMTLIBv2Parser::RuleCmd_declareConst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(647);
    match(SMTLIBv2Parser::CMD_DeclareConst);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_declareDatatypeContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_declareDatatypeContext::Cmd_declareDatatypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_declareDatatypeContext::CMD_DeclareDatatype() {
  return getToken(SMTLIBv2Parser::CMD_DeclareDatatype, 0);
}


size_t SMTLIBv2Parser::Cmd_declareDatatypeContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_declareDatatype;
}

void SMTLIBv2Parser::Cmd_declareDatatypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_declareDatatype(this);
}

void SMTLIBv2Parser::Cmd_declareDatatypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_declareDatatype(this);
}


std::any SMTLIBv2Parser::Cmd_declareDatatypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_declareDatatype(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_declareDatatypeContext* SMTLIBv2Parser::cmd_declareDatatype() {
  Cmd_declareDatatypeContext *_localctx = _tracker.createInstance<Cmd_declareDatatypeContext>(_ctx, getState());
  enterRule(_localctx, 94, SMTLIBv2Parser::RuleCmd_declareDatatype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(649);
    match(SMTLIBv2Parser::CMD_DeclareDatatype);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_declareDatatypesContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_declareDatatypesContext::Cmd_declareDatatypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_declareDatatypesContext::CMD_DeclareDatatypes() {
  return getToken(SMTLIBv2Parser::CMD_DeclareDatatypes, 0);
}


size_t SMTLIBv2Parser::Cmd_declareDatatypesContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_declareDatatypes;
}

void SMTLIBv2Parser::Cmd_declareDatatypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_declareDatatypes(this);
}

void SMTLIBv2Parser::Cmd_declareDatatypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_declareDatatypes(this);
}


std::any SMTLIBv2Parser::Cmd_declareDatatypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_declareDatatypes(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_declareDatatypesContext* SMTLIBv2Parser::cmd_declareDatatypes() {
  Cmd_declareDatatypesContext *_localctx = _tracker.createInstance<Cmd_declareDatatypesContext>(_ctx, getState());
  enterRule(_localctx, 96, SMTLIBv2Parser::RuleCmd_declareDatatypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(651);
    match(SMTLIBv2Parser::CMD_DeclareDatatypes);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_declareFunContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_declareFunContext::Cmd_declareFunContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_declareFunContext::CMD_DeclareFun() {
  return getToken(SMTLIBv2Parser::CMD_DeclareFun, 0);
}


size_t SMTLIBv2Parser::Cmd_declareFunContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_declareFun;
}

void SMTLIBv2Parser::Cmd_declareFunContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_declareFun(this);
}

void SMTLIBv2Parser::Cmd_declareFunContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_declareFun(this);
}


std::any SMTLIBv2Parser::Cmd_declareFunContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_declareFun(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_declareFunContext* SMTLIBv2Parser::cmd_declareFun() {
  Cmd_declareFunContext *_localctx = _tracker.createInstance<Cmd_declareFunContext>(_ctx, getState());
  enterRule(_localctx, 98, SMTLIBv2Parser::RuleCmd_declareFun);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(653);
    match(SMTLIBv2Parser::CMD_DeclareFun);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_declareSortContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_declareSortContext::Cmd_declareSortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_declareSortContext::CMD_DeclareSort() {
  return getToken(SMTLIBv2Parser::CMD_DeclareSort, 0);
}


size_t SMTLIBv2Parser::Cmd_declareSortContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_declareSort;
}

void SMTLIBv2Parser::Cmd_declareSortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_declareSort(this);
}

void SMTLIBv2Parser::Cmd_declareSortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_declareSort(this);
}


std::any SMTLIBv2Parser::Cmd_declareSortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_declareSort(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_declareSortContext* SMTLIBv2Parser::cmd_declareSort() {
  Cmd_declareSortContext *_localctx = _tracker.createInstance<Cmd_declareSortContext>(_ctx, getState());
  enterRule(_localctx, 100, SMTLIBv2Parser::RuleCmd_declareSort);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(655);
    match(SMTLIBv2Parser::CMD_DeclareSort);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_defineFunContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_defineFunContext::Cmd_defineFunContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_defineFunContext::CMD_DefineFun() {
  return getToken(SMTLIBv2Parser::CMD_DefineFun, 0);
}


size_t SMTLIBv2Parser::Cmd_defineFunContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_defineFun;
}

void SMTLIBv2Parser::Cmd_defineFunContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_defineFun(this);
}

void SMTLIBv2Parser::Cmd_defineFunContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_defineFun(this);
}


std::any SMTLIBv2Parser::Cmd_defineFunContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_defineFun(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_defineFunContext* SMTLIBv2Parser::cmd_defineFun() {
  Cmd_defineFunContext *_localctx = _tracker.createInstance<Cmd_defineFunContext>(_ctx, getState());
  enterRule(_localctx, 102, SMTLIBv2Parser::RuleCmd_defineFun);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(657);
    match(SMTLIBv2Parser::CMD_DefineFun);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_defineFunRecContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_defineFunRecContext::Cmd_defineFunRecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_defineFunRecContext::CMD_DefineFunRec() {
  return getToken(SMTLIBv2Parser::CMD_DefineFunRec, 0);
}


size_t SMTLIBv2Parser::Cmd_defineFunRecContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_defineFunRec;
}

void SMTLIBv2Parser::Cmd_defineFunRecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_defineFunRec(this);
}

void SMTLIBv2Parser::Cmd_defineFunRecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_defineFunRec(this);
}


std::any SMTLIBv2Parser::Cmd_defineFunRecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_defineFunRec(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_defineFunRecContext* SMTLIBv2Parser::cmd_defineFunRec() {
  Cmd_defineFunRecContext *_localctx = _tracker.createInstance<Cmd_defineFunRecContext>(_ctx, getState());
  enterRule(_localctx, 104, SMTLIBv2Parser::RuleCmd_defineFunRec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(659);
    match(SMTLIBv2Parser::CMD_DefineFunRec);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_defineFunsRecContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_defineFunsRecContext::Cmd_defineFunsRecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_defineFunsRecContext::CMD_DefineFunsRec() {
  return getToken(SMTLIBv2Parser::CMD_DefineFunsRec, 0);
}


size_t SMTLIBv2Parser::Cmd_defineFunsRecContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_defineFunsRec;
}

void SMTLIBv2Parser::Cmd_defineFunsRecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_defineFunsRec(this);
}

void SMTLIBv2Parser::Cmd_defineFunsRecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_defineFunsRec(this);
}


std::any SMTLIBv2Parser::Cmd_defineFunsRecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_defineFunsRec(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_defineFunsRecContext* SMTLIBv2Parser::cmd_defineFunsRec() {
  Cmd_defineFunsRecContext *_localctx = _tracker.createInstance<Cmd_defineFunsRecContext>(_ctx, getState());
  enterRule(_localctx, 106, SMTLIBv2Parser::RuleCmd_defineFunsRec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(661);
    match(SMTLIBv2Parser::CMD_DefineFunsRec);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_defineSortContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_defineSortContext::Cmd_defineSortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_defineSortContext::CMD_DefineSort() {
  return getToken(SMTLIBv2Parser::CMD_DefineSort, 0);
}


size_t SMTLIBv2Parser::Cmd_defineSortContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_defineSort;
}

void SMTLIBv2Parser::Cmd_defineSortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_defineSort(this);
}

void SMTLIBv2Parser::Cmd_defineSortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_defineSort(this);
}


std::any SMTLIBv2Parser::Cmd_defineSortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_defineSort(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_defineSortContext* SMTLIBv2Parser::cmd_defineSort() {
  Cmd_defineSortContext *_localctx = _tracker.createInstance<Cmd_defineSortContext>(_ctx, getState());
  enterRule(_localctx, 108, SMTLIBv2Parser::RuleCmd_defineSort);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(663);
    match(SMTLIBv2Parser::CMD_DefineSort);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_echoContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_echoContext::Cmd_echoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_echoContext::CMD_Echo() {
  return getToken(SMTLIBv2Parser::CMD_Echo, 0);
}


size_t SMTLIBv2Parser::Cmd_echoContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_echo;
}

void SMTLIBv2Parser::Cmd_echoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_echo(this);
}

void SMTLIBv2Parser::Cmd_echoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_echo(this);
}


std::any SMTLIBv2Parser::Cmd_echoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_echo(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_echoContext* SMTLIBv2Parser::cmd_echo() {
  Cmd_echoContext *_localctx = _tracker.createInstance<Cmd_echoContext>(_ctx, getState());
  enterRule(_localctx, 110, SMTLIBv2Parser::RuleCmd_echo);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(665);
    match(SMTLIBv2Parser::CMD_Echo);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_exitContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_exitContext::Cmd_exitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_exitContext::CMD_Exit() {
  return getToken(SMTLIBv2Parser::CMD_Exit, 0);
}


size_t SMTLIBv2Parser::Cmd_exitContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_exit;
}

void SMTLIBv2Parser::Cmd_exitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_exit(this);
}

void SMTLIBv2Parser::Cmd_exitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_exit(this);
}


std::any SMTLIBv2Parser::Cmd_exitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_exit(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_exitContext* SMTLIBv2Parser::cmd_exit() {
  Cmd_exitContext *_localctx = _tracker.createInstance<Cmd_exitContext>(_ctx, getState());
  enterRule(_localctx, 112, SMTLIBv2Parser::RuleCmd_exit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(667);
    match(SMTLIBv2Parser::CMD_Exit);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getAssertionsContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getAssertionsContext::Cmd_getAssertionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getAssertionsContext::CMD_GetAssertions() {
  return getToken(SMTLIBv2Parser::CMD_GetAssertions, 0);
}


size_t SMTLIBv2Parser::Cmd_getAssertionsContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getAssertions;
}

void SMTLIBv2Parser::Cmd_getAssertionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getAssertions(this);
}

void SMTLIBv2Parser::Cmd_getAssertionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getAssertions(this);
}


std::any SMTLIBv2Parser::Cmd_getAssertionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getAssertions(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getAssertionsContext* SMTLIBv2Parser::cmd_getAssertions() {
  Cmd_getAssertionsContext *_localctx = _tracker.createInstance<Cmd_getAssertionsContext>(_ctx, getState());
  enterRule(_localctx, 114, SMTLIBv2Parser::RuleCmd_getAssertions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(669);
    match(SMTLIBv2Parser::CMD_GetAssertions);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getAssignmentContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getAssignmentContext::Cmd_getAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getAssignmentContext::CMD_GetAssignment() {
  return getToken(SMTLIBv2Parser::CMD_GetAssignment, 0);
}


size_t SMTLIBv2Parser::Cmd_getAssignmentContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getAssignment;
}

void SMTLIBv2Parser::Cmd_getAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getAssignment(this);
}

void SMTLIBv2Parser::Cmd_getAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getAssignment(this);
}


std::any SMTLIBv2Parser::Cmd_getAssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getAssignment(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getAssignmentContext* SMTLIBv2Parser::cmd_getAssignment() {
  Cmd_getAssignmentContext *_localctx = _tracker.createInstance<Cmd_getAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 116, SMTLIBv2Parser::RuleCmd_getAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    match(SMTLIBv2Parser::CMD_GetAssignment);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getInfoContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getInfoContext::Cmd_getInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getInfoContext::CMD_GetInfo() {
  return getToken(SMTLIBv2Parser::CMD_GetInfo, 0);
}


size_t SMTLIBv2Parser::Cmd_getInfoContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getInfo;
}

void SMTLIBv2Parser::Cmd_getInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getInfo(this);
}

void SMTLIBv2Parser::Cmd_getInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getInfo(this);
}


std::any SMTLIBv2Parser::Cmd_getInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getInfo(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getInfoContext* SMTLIBv2Parser::cmd_getInfo() {
  Cmd_getInfoContext *_localctx = _tracker.createInstance<Cmd_getInfoContext>(_ctx, getState());
  enterRule(_localctx, 118, SMTLIBv2Parser::RuleCmd_getInfo);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(673);
    match(SMTLIBv2Parser::CMD_GetInfo);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getModelContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getModelContext::Cmd_getModelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getModelContext::CMD_GetModel() {
  return getToken(SMTLIBv2Parser::CMD_GetModel, 0);
}


size_t SMTLIBv2Parser::Cmd_getModelContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getModel;
}

void SMTLIBv2Parser::Cmd_getModelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getModel(this);
}

void SMTLIBv2Parser::Cmd_getModelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getModel(this);
}


std::any SMTLIBv2Parser::Cmd_getModelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getModel(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getModelContext* SMTLIBv2Parser::cmd_getModel() {
  Cmd_getModelContext *_localctx = _tracker.createInstance<Cmd_getModelContext>(_ctx, getState());
  enterRule(_localctx, 120, SMTLIBv2Parser::RuleCmd_getModel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(675);
    match(SMTLIBv2Parser::CMD_GetModel);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getOptionContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getOptionContext::Cmd_getOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getOptionContext::CMD_GetOption() {
  return getToken(SMTLIBv2Parser::CMD_GetOption, 0);
}


size_t SMTLIBv2Parser::Cmd_getOptionContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getOption;
}

void SMTLIBv2Parser::Cmd_getOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getOption(this);
}

void SMTLIBv2Parser::Cmd_getOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getOption(this);
}


std::any SMTLIBv2Parser::Cmd_getOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getOption(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getOptionContext* SMTLIBv2Parser::cmd_getOption() {
  Cmd_getOptionContext *_localctx = _tracker.createInstance<Cmd_getOptionContext>(_ctx, getState());
  enterRule(_localctx, 122, SMTLIBv2Parser::RuleCmd_getOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(677);
    match(SMTLIBv2Parser::CMD_GetOption);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getProofContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getProofContext::Cmd_getProofContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getProofContext::CMD_GetProof() {
  return getToken(SMTLIBv2Parser::CMD_GetProof, 0);
}


size_t SMTLIBv2Parser::Cmd_getProofContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getProof;
}

void SMTLIBv2Parser::Cmd_getProofContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getProof(this);
}

void SMTLIBv2Parser::Cmd_getProofContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getProof(this);
}


std::any SMTLIBv2Parser::Cmd_getProofContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getProof(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getProofContext* SMTLIBv2Parser::cmd_getProof() {
  Cmd_getProofContext *_localctx = _tracker.createInstance<Cmd_getProofContext>(_ctx, getState());
  enterRule(_localctx, 124, SMTLIBv2Parser::RuleCmd_getProof);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(679);
    match(SMTLIBv2Parser::CMD_GetProof);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getUnsatAssumptionsContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext::Cmd_getUnsatAssumptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext::CMD_GetUnsatAssumptions() {
  return getToken(SMTLIBv2Parser::CMD_GetUnsatAssumptions, 0);
}


size_t SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getUnsatAssumptions;
}

void SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getUnsatAssumptions(this);
}

void SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getUnsatAssumptions(this);
}


std::any SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getUnsatAssumptions(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext* SMTLIBv2Parser::cmd_getUnsatAssumptions() {
  Cmd_getUnsatAssumptionsContext *_localctx = _tracker.createInstance<Cmd_getUnsatAssumptionsContext>(_ctx, getState());
  enterRule(_localctx, 126, SMTLIBv2Parser::RuleCmd_getUnsatAssumptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(681);
    match(SMTLIBv2Parser::CMD_GetUnsatAssumptions);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getUnsatCoreContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getUnsatCoreContext::Cmd_getUnsatCoreContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getUnsatCoreContext::CMD_GetUnsatCore() {
  return getToken(SMTLIBv2Parser::CMD_GetUnsatCore, 0);
}


size_t SMTLIBv2Parser::Cmd_getUnsatCoreContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getUnsatCore;
}

void SMTLIBv2Parser::Cmd_getUnsatCoreContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getUnsatCore(this);
}

void SMTLIBv2Parser::Cmd_getUnsatCoreContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getUnsatCore(this);
}


std::any SMTLIBv2Parser::Cmd_getUnsatCoreContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getUnsatCore(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getUnsatCoreContext* SMTLIBv2Parser::cmd_getUnsatCore() {
  Cmd_getUnsatCoreContext *_localctx = _tracker.createInstance<Cmd_getUnsatCoreContext>(_ctx, getState());
  enterRule(_localctx, 128, SMTLIBv2Parser::RuleCmd_getUnsatCore);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(683);
    match(SMTLIBv2Parser::CMD_GetUnsatCore);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_getValueContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_getValueContext::Cmd_getValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_getValueContext::CMD_GetValue() {
  return getToken(SMTLIBv2Parser::CMD_GetValue, 0);
}


size_t SMTLIBv2Parser::Cmd_getValueContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_getValue;
}

void SMTLIBv2Parser::Cmd_getValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_getValue(this);
}

void SMTLIBv2Parser::Cmd_getValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_getValue(this);
}


std::any SMTLIBv2Parser::Cmd_getValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_getValue(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_getValueContext* SMTLIBv2Parser::cmd_getValue() {
  Cmd_getValueContext *_localctx = _tracker.createInstance<Cmd_getValueContext>(_ctx, getState());
  enterRule(_localctx, 130, SMTLIBv2Parser::RuleCmd_getValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(685);
    match(SMTLIBv2Parser::CMD_GetValue);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_popContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_popContext::Cmd_popContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_popContext::CMD_Pop() {
  return getToken(SMTLIBv2Parser::CMD_Pop, 0);
}


size_t SMTLIBv2Parser::Cmd_popContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_pop;
}

void SMTLIBv2Parser::Cmd_popContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_pop(this);
}

void SMTLIBv2Parser::Cmd_popContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_pop(this);
}


std::any SMTLIBv2Parser::Cmd_popContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_pop(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_popContext* SMTLIBv2Parser::cmd_pop() {
  Cmd_popContext *_localctx = _tracker.createInstance<Cmd_popContext>(_ctx, getState());
  enterRule(_localctx, 132, SMTLIBv2Parser::RuleCmd_pop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(687);
    match(SMTLIBv2Parser::CMD_Pop);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_pushContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_pushContext::Cmd_pushContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_pushContext::CMD_Push() {
  return getToken(SMTLIBv2Parser::CMD_Push, 0);
}


size_t SMTLIBv2Parser::Cmd_pushContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_push;
}

void SMTLIBv2Parser::Cmd_pushContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_push(this);
}

void SMTLIBv2Parser::Cmd_pushContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_push(this);
}


std::any SMTLIBv2Parser::Cmd_pushContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_push(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_pushContext* SMTLIBv2Parser::cmd_push() {
  Cmd_pushContext *_localctx = _tracker.createInstance<Cmd_pushContext>(_ctx, getState());
  enterRule(_localctx, 134, SMTLIBv2Parser::RuleCmd_push);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(689);
    match(SMTLIBv2Parser::CMD_Push);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_resetContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_resetContext::Cmd_resetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_resetContext::CMD_Reset() {
  return getToken(SMTLIBv2Parser::CMD_Reset, 0);
}


size_t SMTLIBv2Parser::Cmd_resetContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_reset;
}

void SMTLIBv2Parser::Cmd_resetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_reset(this);
}

void SMTLIBv2Parser::Cmd_resetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_reset(this);
}


std::any SMTLIBv2Parser::Cmd_resetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_reset(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_resetContext* SMTLIBv2Parser::cmd_reset() {
  Cmd_resetContext *_localctx = _tracker.createInstance<Cmd_resetContext>(_ctx, getState());
  enterRule(_localctx, 136, SMTLIBv2Parser::RuleCmd_reset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(691);
    match(SMTLIBv2Parser::CMD_Reset);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_resetAssertionsContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_resetAssertionsContext::Cmd_resetAssertionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_resetAssertionsContext::CMD_ResetAssertions() {
  return getToken(SMTLIBv2Parser::CMD_ResetAssertions, 0);
}


size_t SMTLIBv2Parser::Cmd_resetAssertionsContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_resetAssertions;
}

void SMTLIBv2Parser::Cmd_resetAssertionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_resetAssertions(this);
}

void SMTLIBv2Parser::Cmd_resetAssertionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_resetAssertions(this);
}


std::any SMTLIBv2Parser::Cmd_resetAssertionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_resetAssertions(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_resetAssertionsContext* SMTLIBv2Parser::cmd_resetAssertions() {
  Cmd_resetAssertionsContext *_localctx = _tracker.createInstance<Cmd_resetAssertionsContext>(_ctx, getState());
  enterRule(_localctx, 138, SMTLIBv2Parser::RuleCmd_resetAssertions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(693);
    match(SMTLIBv2Parser::CMD_ResetAssertions);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_setInfoContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_setInfoContext::Cmd_setInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_setInfoContext::CMD_SetInfo() {
  return getToken(SMTLIBv2Parser::CMD_SetInfo, 0);
}


size_t SMTLIBv2Parser::Cmd_setInfoContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_setInfo;
}

void SMTLIBv2Parser::Cmd_setInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_setInfo(this);
}

void SMTLIBv2Parser::Cmd_setInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_setInfo(this);
}


std::any SMTLIBv2Parser::Cmd_setInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_setInfo(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_setInfoContext* SMTLIBv2Parser::cmd_setInfo() {
  Cmd_setInfoContext *_localctx = _tracker.createInstance<Cmd_setInfoContext>(_ctx, getState());
  enterRule(_localctx, 140, SMTLIBv2Parser::RuleCmd_setInfo);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(695);
    match(SMTLIBv2Parser::CMD_SetInfo);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_setLogicContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_setLogicContext::Cmd_setLogicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_setLogicContext::CMD_SetLogic() {
  return getToken(SMTLIBv2Parser::CMD_SetLogic, 0);
}


size_t SMTLIBv2Parser::Cmd_setLogicContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_setLogic;
}

void SMTLIBv2Parser::Cmd_setLogicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_setLogic(this);
}

void SMTLIBv2Parser::Cmd_setLogicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_setLogic(this);
}


std::any SMTLIBv2Parser::Cmd_setLogicContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_setLogic(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_setLogicContext* SMTLIBv2Parser::cmd_setLogic() {
  Cmd_setLogicContext *_localctx = _tracker.createInstance<Cmd_setLogicContext>(_ctx, getState());
  enterRule(_localctx, 142, SMTLIBv2Parser::RuleCmd_setLogic);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(SMTLIBv2Parser::CMD_SetLogic);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmd_setOptionContext ------------------------------------------------------------------

SMTLIBv2Parser::Cmd_setOptionContext::Cmd_setOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Cmd_setOptionContext::CMD_SetOption() {
  return getToken(SMTLIBv2Parser::CMD_SetOption, 0);
}


size_t SMTLIBv2Parser::Cmd_setOptionContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCmd_setOption;
}

void SMTLIBv2Parser::Cmd_setOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd_setOption(this);
}

void SMTLIBv2Parser::Cmd_setOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd_setOption(this);
}


std::any SMTLIBv2Parser::Cmd_setOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCmd_setOption(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Cmd_setOptionContext* SMTLIBv2Parser::cmd_setOption() {
  Cmd_setOptionContext *_localctx = _tracker.createInstance<Cmd_setOptionContext>(_ctx, getState());
  enterRule(_localctx, 144, SMTLIBv2Parser::RuleCmd_setOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(699);
    match(SMTLIBv2Parser::CMD_SetOption);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommandContext ------------------------------------------------------------------

SMTLIBv2Parser::CommandContext::CommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::CommandContext::ParOpen() {
  return getTokens(SMTLIBv2Parser::ParOpen);
}

tree::TerminalNode* SMTLIBv2Parser::CommandContext::ParOpen(size_t i) {
  return getToken(SMTLIBv2Parser::ParOpen, i);
}

SMTLIBv2Parser::Cmd_assertContext* SMTLIBv2Parser::CommandContext::cmd_assert() {
  return getRuleContext<SMTLIBv2Parser::Cmd_assertContext>(0);
}

std::vector<SMTLIBv2Parser::TermContext *> SMTLIBv2Parser::CommandContext::term() {
  return getRuleContexts<SMTLIBv2Parser::TermContext>();
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::CommandContext::term(size_t i) {
  return getRuleContext<SMTLIBv2Parser::TermContext>(i);
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::CommandContext::ParClose() {
  return getTokens(SMTLIBv2Parser::ParClose);
}

tree::TerminalNode* SMTLIBv2Parser::CommandContext::ParClose(size_t i) {
  return getToken(SMTLIBv2Parser::ParClose, i);
}

SMTLIBv2Parser::Cmd_checkSatContext* SMTLIBv2Parser::CommandContext::cmd_checkSat() {
  return getRuleContext<SMTLIBv2Parser::Cmd_checkSatContext>(0);
}

SMTLIBv2Parser::Cmd_checkSatAssumingContext* SMTLIBv2Parser::CommandContext::cmd_checkSatAssuming() {
  return getRuleContext<SMTLIBv2Parser::Cmd_checkSatAssumingContext>(0);
}

SMTLIBv2Parser::Cmd_declareConstContext* SMTLIBv2Parser::CommandContext::cmd_declareConst() {
  return getRuleContext<SMTLIBv2Parser::Cmd_declareConstContext>(0);
}

std::vector<SMTLIBv2Parser::SymbolContext *> SMTLIBv2Parser::CommandContext::symbol() {
  return getRuleContexts<SMTLIBv2Parser::SymbolContext>();
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::CommandContext::symbol(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(i);
}

std::vector<SMTLIBv2Parser::SortContext *> SMTLIBv2Parser::CommandContext::sort() {
  return getRuleContexts<SMTLIBv2Parser::SortContext>();
}

SMTLIBv2Parser::SortContext* SMTLIBv2Parser::CommandContext::sort(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SortContext>(i);
}

SMTLIBv2Parser::Cmd_declareDatatypeContext* SMTLIBv2Parser::CommandContext::cmd_declareDatatype() {
  return getRuleContext<SMTLIBv2Parser::Cmd_declareDatatypeContext>(0);
}

std::vector<SMTLIBv2Parser::Datatype_decContext *> SMTLIBv2Parser::CommandContext::datatype_dec() {
  return getRuleContexts<SMTLIBv2Parser::Datatype_decContext>();
}

SMTLIBv2Parser::Datatype_decContext* SMTLIBv2Parser::CommandContext::datatype_dec(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Datatype_decContext>(i);
}

SMTLIBv2Parser::Cmd_declareDatatypesContext* SMTLIBv2Parser::CommandContext::cmd_declareDatatypes() {
  return getRuleContext<SMTLIBv2Parser::Cmd_declareDatatypesContext>(0);
}

std::vector<SMTLIBv2Parser::Sort_decContext *> SMTLIBv2Parser::CommandContext::sort_dec() {
  return getRuleContexts<SMTLIBv2Parser::Sort_decContext>();
}

SMTLIBv2Parser::Sort_decContext* SMTLIBv2Parser::CommandContext::sort_dec(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Sort_decContext>(i);
}

SMTLIBv2Parser::Cmd_declareFunContext* SMTLIBv2Parser::CommandContext::cmd_declareFun() {
  return getRuleContext<SMTLIBv2Parser::Cmd_declareFunContext>(0);
}

SMTLIBv2Parser::Cmd_declareSortContext* SMTLIBv2Parser::CommandContext::cmd_declareSort() {
  return getRuleContext<SMTLIBv2Parser::Cmd_declareSortContext>(0);
}

SMTLIBv2Parser::NumeralContext* SMTLIBv2Parser::CommandContext::numeral() {
  return getRuleContext<SMTLIBv2Parser::NumeralContext>(0);
}

SMTLIBv2Parser::Cmd_defineFunContext* SMTLIBv2Parser::CommandContext::cmd_defineFun() {
  return getRuleContext<SMTLIBv2Parser::Cmd_defineFunContext>(0);
}

SMTLIBv2Parser::Function_defContext* SMTLIBv2Parser::CommandContext::function_def() {
  return getRuleContext<SMTLIBv2Parser::Function_defContext>(0);
}

SMTLIBv2Parser::Cmd_defineFunRecContext* SMTLIBv2Parser::CommandContext::cmd_defineFunRec() {
  return getRuleContext<SMTLIBv2Parser::Cmd_defineFunRecContext>(0);
}

SMTLIBv2Parser::Cmd_defineFunsRecContext* SMTLIBv2Parser::CommandContext::cmd_defineFunsRec() {
  return getRuleContext<SMTLIBv2Parser::Cmd_defineFunsRecContext>(0);
}

std::vector<SMTLIBv2Parser::Function_decContext *> SMTLIBv2Parser::CommandContext::function_dec() {
  return getRuleContexts<SMTLIBv2Parser::Function_decContext>();
}

SMTLIBv2Parser::Function_decContext* SMTLIBv2Parser::CommandContext::function_dec(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Function_decContext>(i);
}

SMTLIBv2Parser::Cmd_defineSortContext* SMTLIBv2Parser::CommandContext::cmd_defineSort() {
  return getRuleContext<SMTLIBv2Parser::Cmd_defineSortContext>(0);
}

SMTLIBv2Parser::Cmd_echoContext* SMTLIBv2Parser::CommandContext::cmd_echo() {
  return getRuleContext<SMTLIBv2Parser::Cmd_echoContext>(0);
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::CommandContext::string() {
  return getRuleContext<SMTLIBv2Parser::StringContext>(0);
}

SMTLIBv2Parser::Cmd_exitContext* SMTLIBv2Parser::CommandContext::cmd_exit() {
  return getRuleContext<SMTLIBv2Parser::Cmd_exitContext>(0);
}

SMTLIBv2Parser::Cmd_getAssertionsContext* SMTLIBv2Parser::CommandContext::cmd_getAssertions() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getAssertionsContext>(0);
}

SMTLIBv2Parser::Cmd_getAssignmentContext* SMTLIBv2Parser::CommandContext::cmd_getAssignment() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getAssignmentContext>(0);
}

SMTLIBv2Parser::Cmd_getInfoContext* SMTLIBv2Parser::CommandContext::cmd_getInfo() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getInfoContext>(0);
}

SMTLIBv2Parser::Info_flagContext* SMTLIBv2Parser::CommandContext::info_flag() {
  return getRuleContext<SMTLIBv2Parser::Info_flagContext>(0);
}

SMTLIBv2Parser::Cmd_getModelContext* SMTLIBv2Parser::CommandContext::cmd_getModel() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getModelContext>(0);
}

SMTLIBv2Parser::Cmd_getOptionContext* SMTLIBv2Parser::CommandContext::cmd_getOption() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getOptionContext>(0);
}

SMTLIBv2Parser::KeywordContext* SMTLIBv2Parser::CommandContext::keyword() {
  return getRuleContext<SMTLIBv2Parser::KeywordContext>(0);
}

SMTLIBv2Parser::Cmd_getProofContext* SMTLIBv2Parser::CommandContext::cmd_getProof() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getProofContext>(0);
}

SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext* SMTLIBv2Parser::CommandContext::cmd_getUnsatAssumptions() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getUnsatAssumptionsContext>(0);
}

SMTLIBv2Parser::Cmd_getUnsatCoreContext* SMTLIBv2Parser::CommandContext::cmd_getUnsatCore() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getUnsatCoreContext>(0);
}

SMTLIBv2Parser::Cmd_getValueContext* SMTLIBv2Parser::CommandContext::cmd_getValue() {
  return getRuleContext<SMTLIBv2Parser::Cmd_getValueContext>(0);
}

SMTLIBv2Parser::Cmd_popContext* SMTLIBv2Parser::CommandContext::cmd_pop() {
  return getRuleContext<SMTLIBv2Parser::Cmd_popContext>(0);
}

SMTLIBv2Parser::Cmd_pushContext* SMTLIBv2Parser::CommandContext::cmd_push() {
  return getRuleContext<SMTLIBv2Parser::Cmd_pushContext>(0);
}

SMTLIBv2Parser::Cmd_resetContext* SMTLIBv2Parser::CommandContext::cmd_reset() {
  return getRuleContext<SMTLIBv2Parser::Cmd_resetContext>(0);
}

SMTLIBv2Parser::Cmd_resetAssertionsContext* SMTLIBv2Parser::CommandContext::cmd_resetAssertions() {
  return getRuleContext<SMTLIBv2Parser::Cmd_resetAssertionsContext>(0);
}

SMTLIBv2Parser::Cmd_setInfoContext* SMTLIBv2Parser::CommandContext::cmd_setInfo() {
  return getRuleContext<SMTLIBv2Parser::Cmd_setInfoContext>(0);
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::CommandContext::attribute() {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(0);
}

SMTLIBv2Parser::Cmd_setLogicContext* SMTLIBv2Parser::CommandContext::cmd_setLogic() {
  return getRuleContext<SMTLIBv2Parser::Cmd_setLogicContext>(0);
}

SMTLIBv2Parser::Cmd_setOptionContext* SMTLIBv2Parser::CommandContext::cmd_setOption() {
  return getRuleContext<SMTLIBv2Parser::Cmd_setOptionContext>(0);
}

SMTLIBv2Parser::OptionContext* SMTLIBv2Parser::CommandContext::option() {
  return getRuleContext<SMTLIBv2Parser::OptionContext>(0);
}


size_t SMTLIBv2Parser::CommandContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCommand;
}

void SMTLIBv2Parser::CommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommand(this);
}

void SMTLIBv2Parser::CommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommand(this);
}


std::any SMTLIBv2Parser::CommandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCommand(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::CommandContext* SMTLIBv2Parser::command() {
  CommandContext *_localctx = _tracker.createInstance<CommandContext>(_ctx, getState());
  enterRule(_localctx, 146, SMTLIBv2Parser::RuleCommand);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(893);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(701);
      match(SMTLIBv2Parser::ParOpen);
      setState(702);
      cmd_assert();
      setState(703);
      term();
      setState(704);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(706);
      match(SMTLIBv2Parser::ParOpen);
      setState(707);
      cmd_checkSat();
      setState(708);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(710);
      match(SMTLIBv2Parser::ParOpen);
      setState(711);
      cmd_checkSatAssuming();
      setState(712);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(714);
      match(SMTLIBv2Parser::ParOpen);
      setState(715);
      cmd_declareConst();
      setState(716);
      symbol();
      setState(717);
      sort();
      setState(718);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(720);
      match(SMTLIBv2Parser::ParOpen);
      setState(721);
      cmd_declareDatatype();
      setState(722);
      symbol();
      setState(723);
      datatype_dec();
      setState(724);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(726);
      match(SMTLIBv2Parser::ParOpen);
      setState(727);
      cmd_declareDatatypes();
      setState(728);
      match(SMTLIBv2Parser::ParOpen);
      setState(730); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(729);
        sort_dec();
        setState(732); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(734);
      match(SMTLIBv2Parser::ParClose);
      setState(735);
      match(SMTLIBv2Parser::ParOpen);
      setState(737); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(736);
        datatype_dec();
        setState(739); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(741);
      match(SMTLIBv2Parser::ParClose);
      setState(742);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(744);
      match(SMTLIBv2Parser::ParOpen);
      setState(745);
      cmd_declareFun();
      setState(746);
      symbol();
      setState(747);
      match(SMTLIBv2Parser::ParOpen);
      setState(751);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388548) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol) {
        setState(748);
        sort();
        setState(753);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(754);
      match(SMTLIBv2Parser::ParClose);
      setState(755);
      sort();
      setState(756);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(758);
      match(SMTLIBv2Parser::ParOpen);
      setState(759);
      cmd_declareSort();
      setState(760);
      symbol();
      setState(761);
      numeral();
      setState(762);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(764);
      match(SMTLIBv2Parser::ParOpen);
      setState(765);
      cmd_defineFun();
      setState(766);
      function_def();
      setState(767);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(769);
      match(SMTLIBv2Parser::ParOpen);
      setState(770);
      cmd_defineFunRec();
      setState(771);
      function_def();
      setState(772);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(774);
      match(SMTLIBv2Parser::ParOpen);
      setState(775);
      cmd_defineFunsRec();
      setState(776);
      match(SMTLIBv2Parser::ParOpen);
      setState(778); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(777);
        function_dec();
        setState(780); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(782);
      match(SMTLIBv2Parser::ParClose);
      setState(783);
      match(SMTLIBv2Parser::ParOpen);
      setState(785); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(784);
        term();
        setState(787); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388580) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 70368744177679) != 0));
      setState(789);
      match(SMTLIBv2Parser::ParClose);
      setState(790);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(792);
      match(SMTLIBv2Parser::ParOpen);
      setState(793);
      cmd_defineSort();
      setState(794);
      symbol();
      setState(795);
      match(SMTLIBv2Parser::ParOpen);
      setState(799);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388544) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol) {
        setState(796);
        symbol();
        setState(801);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(802);
      match(SMTLIBv2Parser::ParClose);
      setState(803);
      sort();
      setState(804);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(806);
      match(SMTLIBv2Parser::ParOpen);
      setState(807);
      cmd_echo();
      setState(808);
      string();
      setState(809);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(811);
      match(SMTLIBv2Parser::ParOpen);
      setState(812);
      cmd_exit();
      setState(813);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(815);
      match(SMTLIBv2Parser::ParOpen);
      setState(816);
      cmd_getAssertions();
      setState(817);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(819);
      match(SMTLIBv2Parser::ParOpen);
      setState(820);
      cmd_getAssignment();
      setState(821);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(823);
      match(SMTLIBv2Parser::ParOpen);
      setState(824);
      cmd_getInfo();
      setState(825);
      info_flag();
      setState(826);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(828);
      match(SMTLIBv2Parser::ParOpen);
      setState(829);
      cmd_getModel();
      setState(830);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(832);
      match(SMTLIBv2Parser::ParOpen);
      setState(833);
      cmd_getOption();
      setState(834);
      keyword();
      setState(835);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(837);
      match(SMTLIBv2Parser::ParOpen);
      setState(838);
      cmd_getProof();
      setState(839);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(841);
      match(SMTLIBv2Parser::ParOpen);
      setState(842);
      cmd_getUnsatAssumptions();
      setState(843);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(845);
      match(SMTLIBv2Parser::ParOpen);
      setState(846);
      cmd_getUnsatCore();
      setState(847);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(849);
      match(SMTLIBv2Parser::ParOpen);
      setState(850);
      cmd_getValue();
      setState(851);
      match(SMTLIBv2Parser::ParOpen);
      setState(853); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(852);
        term();
        setState(855); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388580) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 70368744177679) != 0));
      setState(857);
      match(SMTLIBv2Parser::ParClose);
      setState(858);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(860);
      match(SMTLIBv2Parser::ParOpen);
      setState(861);
      cmd_pop();
      setState(862);
      numeral();
      setState(863);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(865);
      match(SMTLIBv2Parser::ParOpen);
      setState(866);
      cmd_push();
      setState(867);
      numeral();
      setState(868);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(870);
      match(SMTLIBv2Parser::ParOpen);
      setState(871);
      cmd_reset();
      setState(872);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(874);
      match(SMTLIBv2Parser::ParOpen);
      setState(875);
      cmd_resetAssertions();
      setState(876);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(878);
      match(SMTLIBv2Parser::ParOpen);
      setState(879);
      cmd_setInfo();
      setState(880);
      attribute();
      setState(881);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(883);
      match(SMTLIBv2Parser::ParOpen);
      setState(884);
      cmd_setLogic();
      setState(885);
      symbol();
      setState(886);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(888);
      match(SMTLIBv2Parser::ParOpen);
      setState(889);
      cmd_setOption();
      setState(890);
      option();
      setState(891);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- B_valueContext ------------------------------------------------------------------

SMTLIBv2Parser::B_valueContext::B_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::B_valueContext::PS_True() {
  return getToken(SMTLIBv2Parser::PS_True, 0);
}

tree::TerminalNode* SMTLIBv2Parser::B_valueContext::PS_False() {
  return getToken(SMTLIBv2Parser::PS_False, 0);
}


size_t SMTLIBv2Parser::B_valueContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleB_value;
}

void SMTLIBv2Parser::B_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterB_value(this);
}

void SMTLIBv2Parser::B_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitB_value(this);
}


std::any SMTLIBv2Parser::B_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitB_value(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::B_valueContext* SMTLIBv2Parser::b_value() {
  B_valueContext *_localctx = _tracker.createInstance<B_valueContext>(_ctx, getState());
  enterRule(_localctx, 148, SMTLIBv2Parser::RuleB_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(895);
    _la = _input->LA(1);
    if (!(_la == SMTLIBv2Parser::PS_False

    || _la == SMTLIBv2Parser::PS_True)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionContext ------------------------------------------------------------------

SMTLIBv2Parser::OptionContext::OptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_DiagnosticOutputChannel() {
  return getToken(SMTLIBv2Parser::PK_DiagnosticOutputChannel, 0);
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::OptionContext::string() {
  return getRuleContext<SMTLIBv2Parser::StringContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_GlobalDeclarations() {
  return getToken(SMTLIBv2Parser::PK_GlobalDeclarations, 0);
}

SMTLIBv2Parser::B_valueContext* SMTLIBv2Parser::OptionContext::b_value() {
  return getRuleContext<SMTLIBv2Parser::B_valueContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_InteractiveMode() {
  return getToken(SMTLIBv2Parser::PK_InteractiveMode, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_PrintSuccess() {
  return getToken(SMTLIBv2Parser::PK_PrintSuccess, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_ProduceAssertions() {
  return getToken(SMTLIBv2Parser::PK_ProduceAssertions, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_ProduceAssignments() {
  return getToken(SMTLIBv2Parser::PK_ProduceAssignments, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_ProduceModels() {
  return getToken(SMTLIBv2Parser::PK_ProduceModels, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_ProduceProofs() {
  return getToken(SMTLIBv2Parser::PK_ProduceProofs, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_ProduceUnsatAssumptions() {
  return getToken(SMTLIBv2Parser::PK_ProduceUnsatAssumptions, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_ProduceUnsatCores() {
  return getToken(SMTLIBv2Parser::PK_ProduceUnsatCores, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_RandomSeed() {
  return getToken(SMTLIBv2Parser::PK_RandomSeed, 0);
}

SMTLIBv2Parser::NumeralContext* SMTLIBv2Parser::OptionContext::numeral() {
  return getRuleContext<SMTLIBv2Parser::NumeralContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_RegularOutputChannel() {
  return getToken(SMTLIBv2Parser::PK_RegularOutputChannel, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_ReproducibleResourceLimit() {
  return getToken(SMTLIBv2Parser::PK_ReproducibleResourceLimit, 0);
}

tree::TerminalNode* SMTLIBv2Parser::OptionContext::PK_Verbosity() {
  return getToken(SMTLIBv2Parser::PK_Verbosity, 0);
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::OptionContext::attribute() {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(0);
}


size_t SMTLIBv2Parser::OptionContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleOption;
}

void SMTLIBv2Parser::OptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption(this);
}

void SMTLIBv2Parser::OptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption(this);
}


std::any SMTLIBv2Parser::OptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitOption(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::OptionContext* SMTLIBv2Parser::option() {
  OptionContext *_localctx = _tracker.createInstance<OptionContext>(_ctx, getState());
  enterRule(_localctx, 150, SMTLIBv2Parser::RuleOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(926);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(897);
      match(SMTLIBv2Parser::PK_DiagnosticOutputChannel);
      setState(898);
      string();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(899);
      match(SMTLIBv2Parser::PK_GlobalDeclarations);
      setState(900);
      b_value();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(901);
      match(SMTLIBv2Parser::PK_InteractiveMode);
      setState(902);
      b_value();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(903);
      match(SMTLIBv2Parser::PK_PrintSuccess);
      setState(904);
      b_value();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(905);
      match(SMTLIBv2Parser::PK_ProduceAssertions);
      setState(906);
      b_value();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(907);
      match(SMTLIBv2Parser::PK_ProduceAssignments);
      setState(908);
      b_value();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(909);
      match(SMTLIBv2Parser::PK_ProduceModels);
      setState(910);
      b_value();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(911);
      match(SMTLIBv2Parser::PK_ProduceProofs);
      setState(912);
      b_value();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(913);
      match(SMTLIBv2Parser::PK_ProduceUnsatAssumptions);
      setState(914);
      b_value();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(915);
      match(SMTLIBv2Parser::PK_ProduceUnsatCores);
      setState(916);
      b_value();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(917);
      match(SMTLIBv2Parser::PK_RandomSeed);
      setState(918);
      numeral();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(919);
      match(SMTLIBv2Parser::PK_RegularOutputChannel);
      setState(920);
      string();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(921);
      match(SMTLIBv2Parser::PK_ReproducibleResourceLimit);
      setState(922);
      numeral();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(923);
      match(SMTLIBv2Parser::PK_Verbosity);
      setState(924);
      numeral();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(925);
      attribute();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Info_flagContext ------------------------------------------------------------------

SMTLIBv2Parser::Info_flagContext::Info_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Info_flagContext::PK_AllStatistics() {
  return getToken(SMTLIBv2Parser::PK_AllStatistics, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_flagContext::PK_AssertionStackLevels() {
  return getToken(SMTLIBv2Parser::PK_AssertionStackLevels, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_flagContext::PK_Authors() {
  return getToken(SMTLIBv2Parser::PK_Authors, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_flagContext::PK_ErrorBehaviour() {
  return getToken(SMTLIBv2Parser::PK_ErrorBehaviour, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_flagContext::PK_Name() {
  return getToken(SMTLIBv2Parser::PK_Name, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_flagContext::PK_ReasonUnknown() {
  return getToken(SMTLIBv2Parser::PK_ReasonUnknown, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_flagContext::PK_Version() {
  return getToken(SMTLIBv2Parser::PK_Version, 0);
}

SMTLIBv2Parser::KeywordContext* SMTLIBv2Parser::Info_flagContext::keyword() {
  return getRuleContext<SMTLIBv2Parser::KeywordContext>(0);
}


size_t SMTLIBv2Parser::Info_flagContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleInfo_flag;
}

void SMTLIBv2Parser::Info_flagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfo_flag(this);
}

void SMTLIBv2Parser::Info_flagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfo_flag(this);
}


std::any SMTLIBv2Parser::Info_flagContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitInfo_flag(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Info_flagContext* SMTLIBv2Parser::info_flag() {
  Info_flagContext *_localctx = _tracker.createInstance<Info_flagContext>(_ctx, getState());
  enterRule(_localctx, 152, SMTLIBv2Parser::RuleInfo_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(936);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(928);
      match(SMTLIBv2Parser::PK_AllStatistics);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(929);
      match(SMTLIBv2Parser::PK_AssertionStackLevels);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(930);
      match(SMTLIBv2Parser::PK_Authors);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(931);
      match(SMTLIBv2Parser::PK_ErrorBehaviour);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(932);
      match(SMTLIBv2Parser::PK_Name);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(933);
      match(SMTLIBv2Parser::PK_ReasonUnknown);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(934);
      match(SMTLIBv2Parser::PK_Version);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(935);
      keyword();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Error_behaviourContext ------------------------------------------------------------------

SMTLIBv2Parser::Error_behaviourContext::Error_behaviourContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Error_behaviourContext::PS_ImmediateExit() {
  return getToken(SMTLIBv2Parser::PS_ImmediateExit, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Error_behaviourContext::PS_ContinuedExecution() {
  return getToken(SMTLIBv2Parser::PS_ContinuedExecution, 0);
}


size_t SMTLIBv2Parser::Error_behaviourContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleError_behaviour;
}

void SMTLIBv2Parser::Error_behaviourContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterError_behaviour(this);
}

void SMTLIBv2Parser::Error_behaviourContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitError_behaviour(this);
}


std::any SMTLIBv2Parser::Error_behaviourContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitError_behaviour(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Error_behaviourContext* SMTLIBv2Parser::error_behaviour() {
  Error_behaviourContext *_localctx = _tracker.createInstance<Error_behaviourContext>(_ctx, getState());
  enterRule(_localctx, 154, SMTLIBv2Parser::RuleError_behaviour);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(938);
    _la = _input->LA(1);
    if (!(_la == SMTLIBv2Parser::PS_ContinuedExecution

    || _la == SMTLIBv2Parser::PS_ImmediateExit)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reason_unknownContext ------------------------------------------------------------------

SMTLIBv2Parser::Reason_unknownContext::Reason_unknownContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Reason_unknownContext::PS_Memout() {
  return getToken(SMTLIBv2Parser::PS_Memout, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Reason_unknownContext::PS_Incomplete() {
  return getToken(SMTLIBv2Parser::PS_Incomplete, 0);
}

SMTLIBv2Parser::S_exprContext* SMTLIBv2Parser::Reason_unknownContext::s_expr() {
  return getRuleContext<SMTLIBv2Parser::S_exprContext>(0);
}


size_t SMTLIBv2Parser::Reason_unknownContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleReason_unknown;
}

void SMTLIBv2Parser::Reason_unknownContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReason_unknown(this);
}

void SMTLIBv2Parser::Reason_unknownContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReason_unknown(this);
}


std::any SMTLIBv2Parser::Reason_unknownContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitReason_unknown(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Reason_unknownContext* SMTLIBv2Parser::reason_unknown() {
  Reason_unknownContext *_localctx = _tracker.createInstance<Reason_unknownContext>(_ctx, getState());
  enterRule(_localctx, 156, SMTLIBv2Parser::RuleReason_unknown);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(943);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(940);
      match(SMTLIBv2Parser::PS_Memout);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(941);
      match(SMTLIBv2Parser::PS_Incomplete);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(942);
      s_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Model_responseContext::Model_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::Model_responseContext::ParOpen() {
  return getTokens(SMTLIBv2Parser::ParOpen);
}

tree::TerminalNode* SMTLIBv2Parser::Model_responseContext::ParOpen(size_t i) {
  return getToken(SMTLIBv2Parser::ParOpen, i);
}

tree::TerminalNode* SMTLIBv2Parser::Model_responseContext::CMD_DefineFun() {
  return getToken(SMTLIBv2Parser::CMD_DefineFun, 0);
}

SMTLIBv2Parser::Function_defContext* SMTLIBv2Parser::Model_responseContext::function_def() {
  return getRuleContext<SMTLIBv2Parser::Function_defContext>(0);
}

std::vector<tree::TerminalNode *> SMTLIBv2Parser::Model_responseContext::ParClose() {
  return getTokens(SMTLIBv2Parser::ParClose);
}

tree::TerminalNode* SMTLIBv2Parser::Model_responseContext::ParClose(size_t i) {
  return getToken(SMTLIBv2Parser::ParClose, i);
}

tree::TerminalNode* SMTLIBv2Parser::Model_responseContext::CMD_DefineFunRec() {
  return getToken(SMTLIBv2Parser::CMD_DefineFunRec, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Model_responseContext::CMD_DefineFunsRec() {
  return getToken(SMTLIBv2Parser::CMD_DefineFunsRec, 0);
}

std::vector<SMTLIBv2Parser::Function_decContext *> SMTLIBv2Parser::Model_responseContext::function_dec() {
  return getRuleContexts<SMTLIBv2Parser::Function_decContext>();
}

SMTLIBv2Parser::Function_decContext* SMTLIBv2Parser::Model_responseContext::function_dec(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Function_decContext>(i);
}

std::vector<SMTLIBv2Parser::TermContext *> SMTLIBv2Parser::Model_responseContext::term() {
  return getRuleContexts<SMTLIBv2Parser::TermContext>();
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::Model_responseContext::term(size_t i) {
  return getRuleContext<SMTLIBv2Parser::TermContext>(i);
}


size_t SMTLIBv2Parser::Model_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleModel_response;
}

void SMTLIBv2Parser::Model_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_response(this);
}

void SMTLIBv2Parser::Model_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_response(this);
}


std::any SMTLIBv2Parser::Model_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitModel_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Model_responseContext* SMTLIBv2Parser::model_response() {
  Model_responseContext *_localctx = _tracker.createInstance<Model_responseContext>(_ctx, getState());
  enterRule(_localctx, 158, SMTLIBv2Parser::RuleModel_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(973);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(945);
      match(SMTLIBv2Parser::ParOpen);
      setState(946);
      match(SMTLIBv2Parser::CMD_DefineFun);
      setState(947);
      function_def();
      setState(948);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(950);
      match(SMTLIBv2Parser::ParOpen);
      setState(951);
      match(SMTLIBv2Parser::CMD_DefineFunRec);
      setState(952);
      function_def();
      setState(953);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(955);
      match(SMTLIBv2Parser::ParOpen);
      setState(956);
      match(SMTLIBv2Parser::CMD_DefineFunsRec);
      setState(957);
      match(SMTLIBv2Parser::ParOpen);
      setState(959); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(958);
        function_dec();
        setState(961); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SMTLIBv2Parser::ParOpen);
      setState(963);
      match(SMTLIBv2Parser::ParClose);
      setState(964);
      match(SMTLIBv2Parser::ParOpen);
      setState(966); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(965);
        term();
        setState(968); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8388580) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 70368744177679) != 0));
      setState(970);
      match(SMTLIBv2Parser::ParClose);
      setState(971);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Info_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Info_responseContext::Info_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Info_responseContext::PK_AssertionStackLevels() {
  return getToken(SMTLIBv2Parser::PK_AssertionStackLevels, 0);
}

SMTLIBv2Parser::NumeralContext* SMTLIBv2Parser::Info_responseContext::numeral() {
  return getRuleContext<SMTLIBv2Parser::NumeralContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_responseContext::PK_Authors() {
  return getToken(SMTLIBv2Parser::PK_Authors, 0);
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::Info_responseContext::string() {
  return getRuleContext<SMTLIBv2Parser::StringContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_responseContext::PK_ErrorBehaviour() {
  return getToken(SMTLIBv2Parser::PK_ErrorBehaviour, 0);
}

SMTLIBv2Parser::Error_behaviourContext* SMTLIBv2Parser::Info_responseContext::error_behaviour() {
  return getRuleContext<SMTLIBv2Parser::Error_behaviourContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_responseContext::PK_Name() {
  return getToken(SMTLIBv2Parser::PK_Name, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_responseContext::PK_ReasonUnknown() {
  return getToken(SMTLIBv2Parser::PK_ReasonUnknown, 0);
}

SMTLIBv2Parser::Reason_unknownContext* SMTLIBv2Parser::Info_responseContext::reason_unknown() {
  return getRuleContext<SMTLIBv2Parser::Reason_unknownContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::Info_responseContext::PK_Version() {
  return getToken(SMTLIBv2Parser::PK_Version, 0);
}

SMTLIBv2Parser::AttributeContext* SMTLIBv2Parser::Info_responseContext::attribute() {
  return getRuleContext<SMTLIBv2Parser::AttributeContext>(0);
}


size_t SMTLIBv2Parser::Info_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleInfo_response;
}

void SMTLIBv2Parser::Info_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfo_response(this);
}

void SMTLIBv2Parser::Info_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfo_response(this);
}


std::any SMTLIBv2Parser::Info_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitInfo_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Info_responseContext* SMTLIBv2Parser::info_response() {
  Info_responseContext *_localctx = _tracker.createInstance<Info_responseContext>(_ctx, getState());
  enterRule(_localctx, 160, SMTLIBv2Parser::RuleInfo_response);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(988);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(975);
      match(SMTLIBv2Parser::PK_AssertionStackLevels);
      setState(976);
      numeral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(977);
      match(SMTLIBv2Parser::PK_Authors);
      setState(978);
      string();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(979);
      match(SMTLIBv2Parser::PK_ErrorBehaviour);
      setState(980);
      error_behaviour();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(981);
      match(SMTLIBv2Parser::PK_Name);
      setState(982);
      string();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(983);
      match(SMTLIBv2Parser::PK_ReasonUnknown);
      setState(984);
      reason_unknown();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(985);
      match(SMTLIBv2Parser::PK_Version);
      setState(986);
      string();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(987);
      attribute();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Valuation_pairContext ------------------------------------------------------------------

SMTLIBv2Parser::Valuation_pairContext::Valuation_pairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Valuation_pairContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

std::vector<SMTLIBv2Parser::TermContext *> SMTLIBv2Parser::Valuation_pairContext::term() {
  return getRuleContexts<SMTLIBv2Parser::TermContext>();
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::Valuation_pairContext::term(size_t i) {
  return getRuleContext<SMTLIBv2Parser::TermContext>(i);
}

tree::TerminalNode* SMTLIBv2Parser::Valuation_pairContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::Valuation_pairContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleValuation_pair;
}

void SMTLIBv2Parser::Valuation_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValuation_pair(this);
}

void SMTLIBv2Parser::Valuation_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValuation_pair(this);
}


std::any SMTLIBv2Parser::Valuation_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitValuation_pair(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Valuation_pairContext* SMTLIBv2Parser::valuation_pair() {
  Valuation_pairContext *_localctx = _tracker.createInstance<Valuation_pairContext>(_ctx, getState());
  enterRule(_localctx, 162, SMTLIBv2Parser::RuleValuation_pair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(990);
    match(SMTLIBv2Parser::ParOpen);
    setState(991);
    term();
    setState(992);
    term();
    setState(993);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T_valuation_pairContext ------------------------------------------------------------------

SMTLIBv2Parser::T_valuation_pairContext::T_valuation_pairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::T_valuation_pairContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::T_valuation_pairContext::symbol() {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(0);
}

SMTLIBv2Parser::B_valueContext* SMTLIBv2Parser::T_valuation_pairContext::b_value() {
  return getRuleContext<SMTLIBv2Parser::B_valueContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::T_valuation_pairContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::T_valuation_pairContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleT_valuation_pair;
}

void SMTLIBv2Parser::T_valuation_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterT_valuation_pair(this);
}

void SMTLIBv2Parser::T_valuation_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitT_valuation_pair(this);
}


std::any SMTLIBv2Parser::T_valuation_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitT_valuation_pair(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::T_valuation_pairContext* SMTLIBv2Parser::t_valuation_pair() {
  T_valuation_pairContext *_localctx = _tracker.createInstance<T_valuation_pairContext>(_ctx, getState());
  enterRule(_localctx, 164, SMTLIBv2Parser::RuleT_valuation_pair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(995);
    match(SMTLIBv2Parser::ParOpen);
    setState(996);
    symbol();
    setState(997);
    b_value();
    setState(998);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Check_sat_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Check_sat_responseContext::Check_sat_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Check_sat_responseContext::PS_Sat() {
  return getToken(SMTLIBv2Parser::PS_Sat, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Check_sat_responseContext::PS_Unsat() {
  return getToken(SMTLIBv2Parser::PS_Unsat, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Check_sat_responseContext::PS_Unknown() {
  return getToken(SMTLIBv2Parser::PS_Unknown, 0);
}


size_t SMTLIBv2Parser::Check_sat_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleCheck_sat_response;
}

void SMTLIBv2Parser::Check_sat_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheck_sat_response(this);
}

void SMTLIBv2Parser::Check_sat_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheck_sat_response(this);
}


std::any SMTLIBv2Parser::Check_sat_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitCheck_sat_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Check_sat_responseContext* SMTLIBv2Parser::check_sat_response() {
  Check_sat_responseContext *_localctx = _tracker.createInstance<Check_sat_responseContext>(_ctx, getState());
  enterRule(_localctx, 166, SMTLIBv2Parser::RuleCheck_sat_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1000);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 5308416) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Echo_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Echo_responseContext::Echo_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::Echo_responseContext::string() {
  return getRuleContext<SMTLIBv2Parser::StringContext>(0);
}


size_t SMTLIBv2Parser::Echo_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleEcho_response;
}

void SMTLIBv2Parser::Echo_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEcho_response(this);
}

void SMTLIBv2Parser::Echo_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEcho_response(this);
}


std::any SMTLIBv2Parser::Echo_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitEcho_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Echo_responseContext* SMTLIBv2Parser::echo_response() {
  Echo_responseContext *_localctx = _tracker.createInstance<Echo_responseContext>(_ctx, getState());
  enterRule(_localctx, 168, SMTLIBv2Parser::RuleEcho_response);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1002);
    string();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_assertions_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_assertions_responseContext::Get_assertions_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Get_assertions_responseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Get_assertions_responseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::TermContext *> SMTLIBv2Parser::Get_assertions_responseContext::term() {
  return getRuleContexts<SMTLIBv2Parser::TermContext>();
}

SMTLIBv2Parser::TermContext* SMTLIBv2Parser::Get_assertions_responseContext::term(size_t i) {
  return getRuleContext<SMTLIBv2Parser::TermContext>(i);
}


size_t SMTLIBv2Parser::Get_assertions_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_assertions_response;
}

void SMTLIBv2Parser::Get_assertions_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_assertions_response(this);
}

void SMTLIBv2Parser::Get_assertions_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_assertions_response(this);
}


std::any SMTLIBv2Parser::Get_assertions_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_assertions_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_assertions_responseContext* SMTLIBv2Parser::get_assertions_response() {
  Get_assertions_responseContext *_localctx = _tracker.createInstance<Get_assertions_responseContext>(_ctx, getState());
  enterRule(_localctx, 170, SMTLIBv2Parser::RuleGet_assertions_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1004);
    match(SMTLIBv2Parser::ParOpen);
    setState(1008);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8388580) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 70368744177679) != 0)) {
      setState(1005);
      term();
      setState(1010);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1011);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_assignment_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_assignment_responseContext::Get_assignment_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Get_assignment_responseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Get_assignment_responseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::T_valuation_pairContext *> SMTLIBv2Parser::Get_assignment_responseContext::t_valuation_pair() {
  return getRuleContexts<SMTLIBv2Parser::T_valuation_pairContext>();
}

SMTLIBv2Parser::T_valuation_pairContext* SMTLIBv2Parser::Get_assignment_responseContext::t_valuation_pair(size_t i) {
  return getRuleContext<SMTLIBv2Parser::T_valuation_pairContext>(i);
}


size_t SMTLIBv2Parser::Get_assignment_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_assignment_response;
}

void SMTLIBv2Parser::Get_assignment_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_assignment_response(this);
}

void SMTLIBv2Parser::Get_assignment_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_assignment_response(this);
}


std::any SMTLIBv2Parser::Get_assignment_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_assignment_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_assignment_responseContext* SMTLIBv2Parser::get_assignment_response() {
  Get_assignment_responseContext *_localctx = _tracker.createInstance<Get_assignment_responseContext>(_ctx, getState());
  enterRule(_localctx, 172, SMTLIBv2Parser::RuleGet_assignment_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1013);
    match(SMTLIBv2Parser::ParOpen);
    setState(1017);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SMTLIBv2Parser::ParOpen) {
      setState(1014);
      t_valuation_pair();
      setState(1019);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1020);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_info_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_info_responseContext::Get_info_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Get_info_responseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Get_info_responseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::Info_responseContext *> SMTLIBv2Parser::Get_info_responseContext::info_response() {
  return getRuleContexts<SMTLIBv2Parser::Info_responseContext>();
}

SMTLIBv2Parser::Info_responseContext* SMTLIBv2Parser::Get_info_responseContext::info_response(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Info_responseContext>(i);
}


size_t SMTLIBv2Parser::Get_info_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_info_response;
}

void SMTLIBv2Parser::Get_info_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_info_response(this);
}

void SMTLIBv2Parser::Get_info_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_info_response(this);
}


std::any SMTLIBv2Parser::Get_info_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_info_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_info_responseContext* SMTLIBv2Parser::get_info_response() {
  Get_info_responseContext *_localctx = _tracker.createInstance<Get_info_responseContext>(_ctx, getState());
  enterRule(_localctx, 174, SMTLIBv2Parser::RuleGet_info_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1022);
    match(SMTLIBv2Parser::ParOpen);
    setState(1024); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1023);
      info_response();
      setState(1026); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 4398046511103) != 0));
    setState(1028);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_model_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_model_responseContext::Get_model_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Get_model_responseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Get_model_responseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::Model_responseContext *> SMTLIBv2Parser::Get_model_responseContext::model_response() {
  return getRuleContexts<SMTLIBv2Parser::Model_responseContext>();
}

SMTLIBv2Parser::Model_responseContext* SMTLIBv2Parser::Get_model_responseContext::model_response(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Model_responseContext>(i);
}


size_t SMTLIBv2Parser::Get_model_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_model_response;
}

void SMTLIBv2Parser::Get_model_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_model_response(this);
}

void SMTLIBv2Parser::Get_model_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_model_response(this);
}


std::any SMTLIBv2Parser::Get_model_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_model_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_model_responseContext* SMTLIBv2Parser::get_model_response() {
  Get_model_responseContext *_localctx = _tracker.createInstance<Get_model_responseContext>(_ctx, getState());
  enterRule(_localctx, 176, SMTLIBv2Parser::RuleGet_model_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1030);
    match(SMTLIBv2Parser::ParOpen);
    setState(1034);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SMTLIBv2Parser::ParOpen) {
      setState(1031);
      model_response();
      setState(1036);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1037);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_option_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_option_responseContext::Get_option_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::Attribute_valueContext* SMTLIBv2Parser::Get_option_responseContext::attribute_value() {
  return getRuleContext<SMTLIBv2Parser::Attribute_valueContext>(0);
}


size_t SMTLIBv2Parser::Get_option_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_option_response;
}

void SMTLIBv2Parser::Get_option_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_option_response(this);
}

void SMTLIBv2Parser::Get_option_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_option_response(this);
}


std::any SMTLIBv2Parser::Get_option_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_option_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_option_responseContext* SMTLIBv2Parser::get_option_response() {
  Get_option_responseContext *_localctx = _tracker.createInstance<Get_option_responseContext>(_ctx, getState());
  enterRule(_localctx, 178, SMTLIBv2Parser::RuleGet_option_response);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1039);
    attribute_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_proof_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_proof_responseContext::Get_proof_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::S_exprContext* SMTLIBv2Parser::Get_proof_responseContext::s_expr() {
  return getRuleContext<SMTLIBv2Parser::S_exprContext>(0);
}


size_t SMTLIBv2Parser::Get_proof_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_proof_response;
}

void SMTLIBv2Parser::Get_proof_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_proof_response(this);
}

void SMTLIBv2Parser::Get_proof_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_proof_response(this);
}


std::any SMTLIBv2Parser::Get_proof_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_proof_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_proof_responseContext* SMTLIBv2Parser::get_proof_response() {
  Get_proof_responseContext *_localctx = _tracker.createInstance<Get_proof_responseContext>(_ctx, getState());
  enterRule(_localctx, 180, SMTLIBv2Parser::RuleGet_proof_response);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1041);
    s_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_unsat_assump_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_unsat_assump_responseContext::Get_unsat_assump_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Get_unsat_assump_responseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Get_unsat_assump_responseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::SymbolContext *> SMTLIBv2Parser::Get_unsat_assump_responseContext::symbol() {
  return getRuleContexts<SMTLIBv2Parser::SymbolContext>();
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Get_unsat_assump_responseContext::symbol(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(i);
}


size_t SMTLIBv2Parser::Get_unsat_assump_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_unsat_assump_response;
}

void SMTLIBv2Parser::Get_unsat_assump_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_unsat_assump_response(this);
}

void SMTLIBv2Parser::Get_unsat_assump_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_unsat_assump_response(this);
}


std::any SMTLIBv2Parser::Get_unsat_assump_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_unsat_assump_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_unsat_assump_responseContext* SMTLIBv2Parser::get_unsat_assump_response() {
  Get_unsat_assump_responseContext *_localctx = _tracker.createInstance<Get_unsat_assump_responseContext>(_ctx, getState());
  enterRule(_localctx, 182, SMTLIBv2Parser::RuleGet_unsat_assump_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1043);
    match(SMTLIBv2Parser::ParOpen);
    setState(1047);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8388544) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol) {
      setState(1044);
      symbol();
      setState(1049);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1050);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_unsat_core_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_unsat_core_responseContext::Get_unsat_core_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Get_unsat_core_responseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Get_unsat_core_responseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::SymbolContext *> SMTLIBv2Parser::Get_unsat_core_responseContext::symbol() {
  return getRuleContexts<SMTLIBv2Parser::SymbolContext>();
}

SMTLIBv2Parser::SymbolContext* SMTLIBv2Parser::Get_unsat_core_responseContext::symbol(size_t i) {
  return getRuleContext<SMTLIBv2Parser::SymbolContext>(i);
}


size_t SMTLIBv2Parser::Get_unsat_core_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_unsat_core_response;
}

void SMTLIBv2Parser::Get_unsat_core_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_unsat_core_response(this);
}

void SMTLIBv2Parser::Get_unsat_core_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_unsat_core_response(this);
}


std::any SMTLIBv2Parser::Get_unsat_core_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_unsat_core_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_unsat_core_responseContext* SMTLIBv2Parser::get_unsat_core_response() {
  Get_unsat_core_responseContext *_localctx = _tracker.createInstance<Get_unsat_core_responseContext>(_ctx, getState());
  enterRule(_localctx, 184, SMTLIBv2Parser::RuleGet_unsat_core_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1052);
    match(SMTLIBv2Parser::ParOpen);
    setState(1056);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8388544) != 0) || _la == SMTLIBv2Parser::UndefinedSymbol) {
      setState(1053);
      symbol();
      setState(1058);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1059);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_value_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Get_value_responseContext::Get_value_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::Get_value_responseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::Get_value_responseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}

std::vector<SMTLIBv2Parser::Valuation_pairContext *> SMTLIBv2Parser::Get_value_responseContext::valuation_pair() {
  return getRuleContexts<SMTLIBv2Parser::Valuation_pairContext>();
}

SMTLIBv2Parser::Valuation_pairContext* SMTLIBv2Parser::Get_value_responseContext::valuation_pair(size_t i) {
  return getRuleContext<SMTLIBv2Parser::Valuation_pairContext>(i);
}


size_t SMTLIBv2Parser::Get_value_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGet_value_response;
}

void SMTLIBv2Parser::Get_value_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_value_response(this);
}

void SMTLIBv2Parser::Get_value_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_value_response(this);
}


std::any SMTLIBv2Parser::Get_value_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGet_value_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Get_value_responseContext* SMTLIBv2Parser::get_value_response() {
  Get_value_responseContext *_localctx = _tracker.createInstance<Get_value_responseContext>(_ctx, getState());
  enterRule(_localctx, 186, SMTLIBv2Parser::RuleGet_value_response);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1061);
    match(SMTLIBv2Parser::ParOpen);
    setState(1063); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1062);
      valuation_pair();
      setState(1065); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SMTLIBv2Parser::ParOpen);
    setState(1067);
    match(SMTLIBv2Parser::ParClose);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specific_success_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::Specific_success_responseContext::Specific_success_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SMTLIBv2Parser::Check_sat_responseContext* SMTLIBv2Parser::Specific_success_responseContext::check_sat_response() {
  return getRuleContext<SMTLIBv2Parser::Check_sat_responseContext>(0);
}

SMTLIBv2Parser::Echo_responseContext* SMTLIBv2Parser::Specific_success_responseContext::echo_response() {
  return getRuleContext<SMTLIBv2Parser::Echo_responseContext>(0);
}

SMTLIBv2Parser::Get_assertions_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_assertions_response() {
  return getRuleContext<SMTLIBv2Parser::Get_assertions_responseContext>(0);
}

SMTLIBv2Parser::Get_assignment_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_assignment_response() {
  return getRuleContext<SMTLIBv2Parser::Get_assignment_responseContext>(0);
}

SMTLIBv2Parser::Get_info_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_info_response() {
  return getRuleContext<SMTLIBv2Parser::Get_info_responseContext>(0);
}

SMTLIBv2Parser::Get_model_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_model_response() {
  return getRuleContext<SMTLIBv2Parser::Get_model_responseContext>(0);
}

SMTLIBv2Parser::Get_option_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_option_response() {
  return getRuleContext<SMTLIBv2Parser::Get_option_responseContext>(0);
}

SMTLIBv2Parser::Get_proof_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_proof_response() {
  return getRuleContext<SMTLIBv2Parser::Get_proof_responseContext>(0);
}

SMTLIBv2Parser::Get_unsat_assump_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_unsat_assump_response() {
  return getRuleContext<SMTLIBv2Parser::Get_unsat_assump_responseContext>(0);
}

SMTLIBv2Parser::Get_unsat_core_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_unsat_core_response() {
  return getRuleContext<SMTLIBv2Parser::Get_unsat_core_responseContext>(0);
}

SMTLIBv2Parser::Get_value_responseContext* SMTLIBv2Parser::Specific_success_responseContext::get_value_response() {
  return getRuleContext<SMTLIBv2Parser::Get_value_responseContext>(0);
}


size_t SMTLIBv2Parser::Specific_success_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleSpecific_success_response;
}

void SMTLIBv2Parser::Specific_success_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecific_success_response(this);
}

void SMTLIBv2Parser::Specific_success_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecific_success_response(this);
}


std::any SMTLIBv2Parser::Specific_success_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitSpecific_success_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::Specific_success_responseContext* SMTLIBv2Parser::specific_success_response() {
  Specific_success_responseContext *_localctx = _tracker.createInstance<Specific_success_responseContext>(_ctx, getState());
  enterRule(_localctx, 188, SMTLIBv2Parser::RuleSpecific_success_response);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1080);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1069);
      check_sat_response();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1070);
      echo_response();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1071);
      get_assertions_response();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1072);
      get_assignment_response();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1073);
      get_info_response();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1074);
      get_model_response();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1075);
      get_option_response();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1076);
      get_proof_response();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1077);
      get_unsat_assump_response();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1078);
      get_unsat_core_response();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1079);
      get_value_response();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- General_responseContext ------------------------------------------------------------------

SMTLIBv2Parser::General_responseContext::General_responseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SMTLIBv2Parser::General_responseContext::PS_Success() {
  return getToken(SMTLIBv2Parser::PS_Success, 0);
}

SMTLIBv2Parser::Specific_success_responseContext* SMTLIBv2Parser::General_responseContext::specific_success_response() {
  return getRuleContext<SMTLIBv2Parser::Specific_success_responseContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::General_responseContext::PS_Unsupported() {
  return getToken(SMTLIBv2Parser::PS_Unsupported, 0);
}

tree::TerminalNode* SMTLIBv2Parser::General_responseContext::ParOpen() {
  return getToken(SMTLIBv2Parser::ParOpen, 0);
}

tree::TerminalNode* SMTLIBv2Parser::General_responseContext::PS_Error() {
  return getToken(SMTLIBv2Parser::PS_Error, 0);
}

SMTLIBv2Parser::StringContext* SMTLIBv2Parser::General_responseContext::string() {
  return getRuleContext<SMTLIBv2Parser::StringContext>(0);
}

tree::TerminalNode* SMTLIBv2Parser::General_responseContext::ParClose() {
  return getToken(SMTLIBv2Parser::ParClose, 0);
}


size_t SMTLIBv2Parser::General_responseContext::getRuleIndex() const {
  return SMTLIBv2Parser::RuleGeneral_response;
}

void SMTLIBv2Parser::General_responseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneral_response(this);
}

void SMTLIBv2Parser::General_responseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SMTLIBv2Listener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneral_response(this);
}


std::any SMTLIBv2Parser::General_responseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SMTLIBv2Visitor*>(visitor))
    return parserVisitor->visitGeneral_response(this);
  else
    return visitor->visitChildren(this);
}

SMTLIBv2Parser::General_responseContext* SMTLIBv2Parser::general_response() {
  General_responseContext *_localctx = _tracker.createInstance<General_responseContext>(_ctx, getState());
  enterRule(_localctx, 190, SMTLIBv2Parser::RuleGeneral_response);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1090);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1082);
      match(SMTLIBv2Parser::PS_Success);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1083);
      specific_success_response();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1084);
      match(SMTLIBv2Parser::PS_Unsupported);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1085);
      match(SMTLIBv2Parser::ParOpen);
      setState(1086);
      match(SMTLIBv2Parser::PS_Error);
      setState(1087);
      string();
      setState(1088);
      match(SMTLIBv2Parser::ParClose);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void SMTLIBv2Parser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  smtlibv2ParserInitialize();
#else
  ::antlr4::internal::call_once(smtlibv2ParserOnceFlag, smtlibv2ParserInitialize);
#endif
}
